<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Reconstruction · MPI Reconstruction</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="MPI Reconstruction logo"/></a><h1>MPI Reconstruction</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="overview.html">Getting Started</a></li><li class="current"><a class="toctext" href="basicReconstruction.html">Basic Reconstruction</a><ul class="internal"><li><a class="toctext" href="#On-Disk-Reconstruction-1">On Disk Reconstruction</a></li><li><a class="toctext" href="#In-Memory-Reconstruction-1">In Memory Reconstruction</a></li><li><a class="toctext" href="#Middle-Level-Reconstruction-1">Middle Level Reconstruction</a></li><li><a class="toctext" href="#Low-Level-Reconstruction-1">Low Level Reconstruction</a></li></ul></li><li><a class="toctext" href="parameters.html">Parameters</a></li><li><a class="toctext" href="recoResults.html">Results</a></li><li><a class="toctext" href="multiContrast.html">Multi-Contrast</a></li><li><a class="toctext" href="multiPatch.html">Multi-Patch</a></li><li><a class="toctext" href="matrixCompression.html">Compression</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="basicReconstruction.html">Basic Reconstruction</a></li></ul><a class="edit-page" href="https://github.com/MagneticParticleImaging/MPIReco.jl/blob/master/docs/src/basicReconstruction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Basic Reconstruction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Basic-Reconstruction-1" href="#Basic-Reconstruction-1">Basic Reconstruction</a></h1><p>MPIReco.jl provides different reconstruction levels. All of these reconstruction routines are called <code>reconstruction</code> and the dispatch is done based on the input types.</p><h2><a class="nav-anchor" id="On-Disk-Reconstruction-1" href="#On-Disk-Reconstruction-1">On Disk Reconstruction</a></h2><p>This is the highest level reconstruction. The function signature is given by</p><pre><code class="language-julia">function reconstruction(d::MDFDatasetStore, study::Study,
                        exp::Experiment, recoParams::Dict)</code></pre><p>This reconstruction is also called an <em>on disk</em> reconstruction because it assumes that one has a data store (i.e. a structured folder of files) where the file location is uniquely determined by the study name and experiment number. All reconstruction parameters are passed to this method by the <code>recoParams</code> dictionary. On disk reconstruction has the advantage that the routine will perform reconstruction only once for a particular set of parameters. If that parameter set has already been reconstructed, the data will loaded from disk. However, the on disk reconstruction needs some experience with dataset stores to set it up correctly and is not suited for unstructured data.</p><h2><a class="nav-anchor" id="In-Memory-Reconstruction-1" href="#In-Memory-Reconstruction-1">In Memory Reconstruction</a></h2><p>The next level is the in memory reconstruction. Its function signature reads</p><pre><code class="language-julia">function reconstruction(recoParams::Dict)</code></pre><p>This routine requires that all parameters are put into a dictionary. An overview how this dictionary looks like is given in the section <a href="parameters.html#Parameters-1">Parameters</a>.</p><p>The above reconstruction method basically does two things</p><ul><li>Pull out the location of measurement data and system matrix from the <code>recoParams</code> dictionary.</li><li>Pass all parameter to the low level reconstruction method in the form of keyword parameters.</li></ul><p>In turn the next level reconstruction looks like this</p><pre><code class="language-julia">function reconstruction(bSF::Union{T,Vector{T}}, bMeas::MPIFile; kargs...)</code></pre><p>There are, however also some reconstruction methods in-between that look like this</p><pre><code class="language-julia">function reconstruction(filenameSF::AbstractString, filenameMeas::AbstractString; kargs...)
function reconstruction(filenameMeas::AbstractString; kargs...)</code></pre><p>In both cases, an MPIFile is created based on the input filename. The second version also guesses the system matrix based on what is stored within the measurement file. This usually only works, if this is executed on a system where the files are stored at exactly the same location as how they have been measured.</p><h2><a class="nav-anchor" id="Middle-Level-Reconstruction-1" href="#Middle-Level-Reconstruction-1">Middle Level Reconstruction</a></h2><p>The middle level reconstruction first checks, whether the dataset is a multi-patch or a single-patch file. Then it will call either <code>reconstructionSinglePatch</code> or <code>reconstructionMultiPatch</code>. Both have essentially the signature</p><pre><code class="language-julia">function reconstructionSinglePatch(bSF::Union{T,Vector{T}}, bMeas::MPIFile;
                                  minFreq=0, maxFreq=1.25e6, SNRThresh=-1,
                                  maxMixingOrder=-1, numUsedFreqs=-1, sortBySNR=false, recChannels=1:numReceivers(bMeas),
                                  bEmpty = nothing, bgFrames = 1, fgFrames = 1,
                                  varMeanThresh = 0, minAmplification=2, kargs...) where {T&lt;:MPIFile}</code></pre><p>Here, one can see various parameters that can be used to control, which frequency components are being used for reconstruction. All these parameters are passed to the <code>filterFrequencies</code> function from <a href="https://github.com/MagneticParticleImaging/MPIFiles.jl">MPIFiles.jl</a>.</p><p>The function <code>reconstructionSinglePatch</code> performs the frequency filtering and then calls</p><pre><code class="language-julia">function reconstruction(bSF::Union{T,Vector{T}}, bMeas::MPIFile, freq::Array;
  bEmpty = nothing, bgFrames = 1,  denoiseWeight = 0, redFactor = 0.0, thresh = nothing,
  loadasreal = false, solver = &quot;kaczmarz&quot;, sparseTrafo = nothing, saveTrafo=false,
  gridsize = gridSizeCommon(bSF), fov=calibFov(bSF), center=[0.0,0.0,0.0], useDFFoV=false,
  deadPixels=Int[], bgCorrectionInternal=false, kargs...) where {T&lt;:MPIFile}</code></pre><p>One can see that the frequency index is passed to this function as the third argument. All new keyword arguments are essentially used for determining the way how the system matrix is loaded. For instance with the parameters <code>gridsize</code>, <code>fov</code>, <code>center</code> it is possible to change the grid at which the system function is being loaded.</p><p>Once the system matrix is loaded, the next lower level function is called:</p><pre><code class="language-julia">function reconstruction(S, bSF::Union{T,Vector{T}}, bMeas::MPIFile, freq::Array, grid;
  frames = nothing, bEmpty = nothing, bgFrames = 1, nAverages = 1, numAverages=nAverages,
  sparseTrafo = nothing, loadasreal = false, maxload = 100, maskDFFOV=false,
  weightType=WeightingType.None, weightingLimit = 0, solver = &quot;kaczmarz&quot;,
  spectralCleaning=true, fgFrames=1:10, bgCorrectionInternal=false,
  noiseFreqThresh=0.0, kargs...) where {T&lt;:MPIFile}</code></pre><p>This function is responsible for loading the measurement data and potential background data that is subtracted from the measurements. For any frame to be reconstructed, the low level reconstruction routine is called.</p><h2><a class="nav-anchor" id="Low-Level-Reconstruction-1" href="#Low-Level-Reconstruction-1">Low Level Reconstruction</a></h2><p>Finally, we have arrived at the low level reconstruction routine that has the signature</p><pre><code class="language-julia">function reconstruction(S, u::Array, shape; sparseTrafo = nothing,
                        lambd=0, progress=nothing, solver = &quot;kaczmarz&quot;,
                        weights=nothing, reshapesolution = true, kargs...)</code></pre><p>One can see that it requires the system matrix <code>S</code> and the measurements <code>u</code> to be already loaded.</p><p>We note that <code>S</code> is typeless for a reason here. For a regular reconstruction one will basically feed in an <code>Array{ComplexF32,2}</code> in here, although more precisely it will be a <code>Transposed</code> version of that type if the <code>Kaczmarz</code> algorithm is being used for efficiency reasons.</p><p>However, in case that matrix compression is applied <code>S</code> will be of type <code>SparseMatrixCSC</code>. And for <a href="multiPatch.html#Multi-Patch-Reconstruction-1">Multi-Patch Reconstruction</a> <code>S</code> will be of type <code>FFOperator</code>. Hence, the solvers are implemented in a very generic way and require only certain functions to be implemented. The low level reconstruction method calls one of the solvers from <a href="https://github.com/tknopp/RegularizedLeastSquares.jl">RegularizedLeastSquares.jl</a>.</p><footer><hr/><a class="previous" href="overview.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="parameters.html"><span class="direction">Next</span><span class="title">Parameters</span></a></footer></article></body></html>
