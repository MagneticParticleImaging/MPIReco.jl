<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imaging Operators · MPIReco</title><meta name="title" content="Imaging Operators · MPIReco"/><meta property="og:title" content="Imaging Operators · MPIReco"/><meta property="twitter:title" content="Imaging Operators · MPIReco"/><meta name="description" content="Documentation for MPIReco."/><meta property="og:description" content="Documentation for MPIReco."/><meta property="twitter:description" content="Documentation for MPIReco."/><meta property="og:url" content="https://github.com/MagneticParticleImaging/MPIReco.jl/generated/explanations/operators/"/><meta property="twitter:url" content="https://github.com/MagneticParticleImaging/MPIReco.jl/generated/explanations/operators/"/><link rel="canonical" href="https://github.com/MagneticParticleImaging/MPIReco.jl/generated/explanations/operators/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="MPIReco logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">MPIReco</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../tutorials/overview/">Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/basicReconstruction/">Basic Reconstructions</a></li><li><a class="tocitem" href="../../tutorials/weighting/">Weighting</a></li><li><a class="tocitem" href="../../tutorials/multiContrast/">Multi-Contrast</a></li><li><a class="tocitem" href="../../tutorials/matrixCompression/">Compression</a></li><li><a class="tocitem" href="../../tutorials/multiPatch/">Multi-Patch</a></li><li><a class="tocitem" href="../../tutorials/gpuAcceleration/">GPU-Acceleration</a></li><li><a class="tocitem" href="../../tutorials/distributed/">Distributed Reconstruction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howtos/solvers/">Change and Configure Solvers</a></li><li><a class="tocitem" href="../../howtos/caching/">Enable Caching</a></li><li><a class="tocitem" href="../../howtos/custom/">Implement Custom Data Processing</a></li><li><a class="tocitem" href="../../howtos/extensions/">Implement Reconstruction Packages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../recoplans/">MPIRecoPlan</a></li><li class="is-active"><a class="tocitem" href>Imaging Operators</a><ul class="internal"><li><a class="tocitem" href="#Linear-Algebra"><span>Linear Algebra</span></a></li><li><a class="tocitem" href="#Matrix-Free"><span>Matrix-Free</span></a></li><li><a class="tocitem" href="#GPU-Acceleration"><span>GPU Acceleration</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../references/utility/">Utility</a></li><li><a class="tocitem" href="../../../references/parameters/">Parameters</a></li><li><a class="tocitem" href="../../../references/singlepatch/">Single-Patch</a></li><li><a class="tocitem" href="../../../references/multipatch/">Multi-Patch</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Explanations</a></li><li class="is-active"><a href>Imaging Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Imaging Operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MagneticParticleImaging/MPIReco.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MagneticParticleImaging/MPIReco.jl/blob/master/docs/src/literate/explanations/operators.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Imaging-Operators"><a class="docs-heading-anchor" href="#Imaging-Operators">Imaging Operators</a><a id="Imaging-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Imaging-Operators" title="Permalink"></a></h1><p>The system-matrix based image reconstruction algorithms provided by MPIReco mainly focus on inverse problems of the form:</p><p class="math-container">\[\begin{equation}
  \underset{\mathbf{c}}{argmin} \frac{1}{2}\vert\vert \mathbf{S}\mathbf{c}-\mathbf{u} \vert\vert_2^2 + + \mathbf{R(x)}
\end{equation}\]</p><p>where <span>$\mathbf{S}$</span> is a system matrix, <span>$\mathbf{u}$</span> is the measurement vector, and <span>$\mathbf{R(x)}$</span> is an (optional) regularization term. In this explanation we will take a closer look at the requirements on <span>$\mathbf{S}$</span>, which is especially relevant if one wants to implement a hybrid- or model based operator for the inverse problem.</p><pre><code class="language-julia hljs">S = randn(256, 256)
c = randn(256)
u = S*c;</code></pre><h2 id="Linear-Algebra"><a class="docs-heading-anchor" href="#Linear-Algebra">Linear Algebra</a><a id="Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra" title="Permalink"></a></h2><p>Different solvers require different interaction with the system matrix <span>$\mathbf{S}$</span>. Kaczmarz itself uses a dot product with the rows of <span>$\mathbf{S}$</span> and the current approximate solution <span>$\mathbf{c}$</span>. Since there is no predefined function for such an operation, RegularizedLeastSquares.jl implemented its own</p><pre><code class="language-julia hljs">using MPIReco.RegularizedLeastSquares
row = 1
isapprox(RegularizedLeastSquares.dot_with_matrix_row(S, c, row), sum(S[row, :] .* c))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Custom operators should implement efficient variants of this function to ensure good performance with the Kaczmarz solver. Since Julia is a column-major order language, this row-based access pattern is quite inefficient for dense arrays. A workaround is to transpose the matrix then pass it to a Kaczmarz solver.</p><pre><code class="language-julia hljs">S_efficient = transpose(collect(transpose(S)))
typeof(S_efficient)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearAlgebra.Transpose{Float64, Matrix{Float64}}</code></pre><p>RegularizedLeastSquares provides an efficient implmentation for this operator.</p><p>Other solvers such as FISTA or CGNR require the normal operator of <span>$\mathbf{S}$</span>, either because they require the gradient of the least squares norm or because the work on an adapted optimization problem. The normal operator <span>$\mathbf{S^*S}$</span> is composed of a matrix-vector product of <span>$\mathbf{S}$</span> followed by matrix-vector product of the adjoint of <span>$\mathbf{S}$</span>. An efficient matrix-vector product is provided in Julia by the LinearAlgebra standard library:</p><pre><code class="language-julia hljs">using LinearAlgebra
mul!(u, S, c)
isapprox(u, S * c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>This inplace variant of a matrix-vector product is used within in RegularizedLeastSquares and also needs to be provided for custom operators.</p><h2 id="Matrix-Free"><a class="docs-heading-anchor" href="#Matrix-Free">Matrix-Free</a><a id="Matrix-Free-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Free" title="Permalink"></a></h2><p>LinearAlgebra also provides a function to compute the adjoint of a matrix-vector product:</p><pre><code class="language-julia hljs">mul!(c, adjoint(S), u)
isapprox(c, adjoint(S) * u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>This function creates a lazy adjoint, i.e. it does not create a new array. Instead it only changes the way the size and indexing into the underyling array works.</p><pre><code class="language-julia hljs">S_adj = adjoint(S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">256×256 adjoint(::Matrix{Float64}) with eltype Float64:
 -0.311725    0.453089    0.194837  …  -0.00351954   0.0283428  -0.604695
  1.73872     0.763285   -0.819632      0.271526     1.53509     1.51333
 -2.20873     0.405926   -0.697457     -1.02205     -0.341413    0.937622
 -1.14848    -1.11625     0.607593     -1.18616     -0.0808885   1.0317
  0.0360504   0.474784    0.645385     -1.60616     -0.058166   -3.40454
  1.06295    -0.0951328   1.41695   …  -0.49936     -0.260777    1.12229
  0.252764   -0.24097     1.95093       0.230175    -0.877666   -0.833705
  1.21477    -1.25805     0.307769     -1.26987      0.270104   -0.740849
 -1.24924     1.54062    -0.969895      0.964627    -1.07804    -1.13006
  1.03405    -0.632744   -0.408233     -0.179889     0.544492   -0.591676
  ⋮                                 ⋱                            ⋮
 -0.246661   -0.179304   -0.819985      0.631199    -1.15707     0.676254
  1.55808    -0.464176   -0.168072      1.18978      1.07837     0.266087
  0.288841   -0.875801    0.269483      0.147472    -1.22727    -0.35187
  0.307169   -1.16513     0.600846  …   1.33613     -1.0118      1.06575
  0.232695    1.02483     1.49937       0.609329     0.170495    0.392109
  0.228995   -2.55908     0.926108      0.96177     -0.664431    1.22061
  1.06347    -0.0676335  -0.378114      1.43317      1.31651     0.886236
 -0.658256   -0.820202    0.21043      -0.582311    -1.88274     0.546773
 -0.123219    1.84708    -0.029054  …   0.271593    -0.981217    0.6377</code></pre><p>A related concepts are matrix-free operators. These are operators which behave like a matrix in a(n adjoint) matrix-vector product, but don&#39;t have an underlying dense matrix.</p><p>There are several different Julia packages with which one can create such matrix-free operators such as LinearOperators.jl or LinearMaps.jl. MPIReco uses the <a href="https://github.com/JuliaImageRecon/LinearOperatorCollection.jl">LinearOperatorCollection.jl</a> package to create matrix-free operators for and with <span>$\mathbf{S}$</span>.</p><pre><code class="language-julia hljs">using MPIReco.LinearOperatorCollection
weights = rand(256)
wop = WeightingOp(weights)
size(wop)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(256, 256)</code></pre><p>For example, LinearOperatorCollection provides a weighting operator. This operator acts as if it is a diagonal matrix, but only requires the elements of the diagonal. We can also do matrix-free matrix product to create <span>$\mathbf{WS}$</span> without calculating the matrix-matrix product:</p><pre><code class="language-julia hljs">WS = ProdOp(wop, S)
isapprox(WS * c, weights .* S * c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Another relevant matrix-free operator is the normal operator:</p><pre><code class="language-julia hljs">SHS = normalOperator(WS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Linear operator
  nrow: 256
  ncol: 256
  eltype: Float64
  symmetric: false
  hermitian: false
  nprod:   0
  ntprod:  0
  nctprod: 0

</code></pre><p>This operator not only computes its matrix-vector product in a lazy fashion, it also optimizes the resulting operator: Without an optimization a matrix-free product would apply the following operator each iteration:</p><p class="math-container">\[\begin{equation}
  (\mathbf{WS})^*\mathbf{WS} = \mathbf{S}^*\mathbf{W}^*\mathbf{W}\mathbf{S}
\end{equation}\]</p><p>This is not efficient and instead the normal operator can be optimized by initially computing the weights:</p><p class="math-container">\[\begin{equation}
  \tilde{\mathbf{W}} = \mathbf{W}^*\mathbf{W}
\end{equation}\]</p><p>and then applying the following each iteration:</p><p class="math-container">\[\begin{equation}
  \mathbf{S}^*\tilde{\mathbf{W}}\mathbf{S}
\end{equation}\]</p><p>And lastly, the efficient multi-patch image reconstruction is based on a matrix-free multi-patch operator. This operator contains system matrices per patch as well as indexing metadata and is able to act like a large dense matrix in a matrix-vector product and can be combined with weighting and the normal operator.</p><h2 id="GPU-Acceleration"><a class="docs-heading-anchor" href="#GPU-Acceleration">GPU Acceleration</a><a id="GPU-Acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Acceleration" title="Permalink"></a></h2><p>GPU acceleration is achieved by adapting <span>$\mathbf{S}$</span> and <span>$\mathbf{u}$</span> to be GPU-compatible data types. In the case of dense arrays, this means the arrays are GPU arrays.</p><p>Matrix-free operators on the other hand don&#39;t necessarily need to be on the GPU. In the case that a matrix-free operator is only a function call, this function only needs to be GPU compatible. In the case of the weighting operator or the matrix-free operator, we need to move the internally used dense arrays to the GPU and can then use them on the GPU.</p><p>To make more complex operators work on the GPU one can either try to formulate a method on GPUArrays which only uses broadcasts. Or alternatively implement a custom GPU kernel with either a specific GPU package such as CUDA.jl or AMDGPU.jl or a vendor-agnostic kernel using KernelAbstractions.jl.</p><p>A related Julia package is also the <a href="https://github.com/JuliaGPU/Adapt.jl">Adapt.jl</a>, which offers the <code>adapt</code> method. This essentially acts like <code>convert(T, a)</code> without the restriction that the result must be of type T. The use case for GPU computing here is to provide the GPU array type T and then return a GPU compatibe version of <code>a</code>, however that might look like.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../recoplans/">« MPIRecoPlan</a><a class="docs-footer-nextpage" href="../../../references/utility/">Utility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 22 July 2025 15:58">Tuesday 22 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
