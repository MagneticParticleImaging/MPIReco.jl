<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imaging Operators · MPIReco</title><meta name="title" content="Imaging Operators · MPIReco"/><meta property="og:title" content="Imaging Operators · MPIReco"/><meta property="twitter:title" content="Imaging Operators · MPIReco"/><meta name="description" content="Documentation for MPIReco."/><meta property="og:description" content="Documentation for MPIReco."/><meta property="twitter:description" content="Documentation for MPIReco."/><meta property="og:url" content="https://github.com/MagneticParticleImaging/MPIReco.jl/generated/explanations/operators/"/><meta property="twitter:url" content="https://github.com/MagneticParticleImaging/MPIReco.jl/generated/explanations/operators/"/><link rel="canonical" href="https://github.com/MagneticParticleImaging/MPIReco.jl/generated/explanations/operators/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="MPIReco logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">MPIReco</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../tutorials/overview/">Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/basicReconstruction/">Basic Reconstructions</a></li><li><a class="tocitem" href="../../tutorials/weighting/">Weighting</a></li><li><a class="tocitem" href="../../tutorials/multiContrast/">Multi-Contrast</a></li><li><a class="tocitem" href="../../tutorials/matrixCompression/">Compression</a></li><li><a class="tocitem" href="../../tutorials/multiPatch/">Multi-Patch</a></li><li><a class="tocitem" href="../../tutorials/lowlevel/">Low-Level</a></li><li><a class="tocitem" href="../../tutorials/gpuAcceleration/">GPU-Acceleration</a></li><li><a class="tocitem" href="../../tutorials/distributed/">Distributed Reconstruction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howtos/solvers/">Change and Configure Solvers</a></li><li><a class="tocitem" href="../../howtos/caching/">Enable Caching</a></li><li><a class="tocitem" href="../../howtos/callbacks/">Use Callbacks</a></li><li><a class="tocitem" href="../../howtos/custom/">Implement Custom Data Processing</a></li><li><a class="tocitem" href="../../howtos/extensions/">Implement Reconstruction Packages</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../datastructures/">Data Structures</a></li><li><a class="tocitem" href="../recoplans/">MPIRecoPlan</a></li><li class="is-active"><a class="tocitem" href>Imaging Operators</a><ul class="internal"><li><a class="tocitem" href="#Linear-Algebra"><span>Linear Algebra</span></a></li><li><a class="tocitem" href="#Matrix-Free"><span>Matrix-Free</span></a></li><li><a class="tocitem" href="#GPU-Acceleration"><span>GPU Acceleration</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../references/utility/">Utility</a></li><li><a class="tocitem" href="../../../references/parameters/">Parameters</a></li><li><a class="tocitem" href="../../../references/singlepatch/">Single-Patch</a></li><li><a class="tocitem" href="../../../references/multipatch/">Multi-Patch</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Explanations</a></li><li class="is-active"><a href>Imaging Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Imaging Operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MagneticParticleImaging/MPIReco.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MagneticParticleImaging/MPIReco.jl/blob/master/docs/src/literate/explanations/operators.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Imaging-Operators"><a class="docs-heading-anchor" href="#Imaging-Operators">Imaging Operators</a><a id="Imaging-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Imaging-Operators" title="Permalink"></a></h1><p>The system-matrix based image reconstruction algorithms provided by MPIReco mainly focus on inverse problems of the form:</p><p class="math-container">\[\begin{equation}
  \underset{\mathbf{c}}{argmin} \frac{1}{2}\vert\vert \mathbf{S}\mathbf{c}-\mathbf{u} \vert\vert_2^2 + + \mathbf{R(x)}
\end{equation}\]</p><p>where <span>$\mathbf{S}$</span> is a system matrix, <span>$\mathbf{u}$</span> is the measurement vector, and <span>$\mathbf{R(x)}$</span> is an (optional) regularization term. In this explanation we will take a closer look at the requirements on <span>$\mathbf{S}$</span>, which is especially relevant if one wants to implement a hybrid- or model based operator for the inverse problem.</p><pre><code class="language-julia hljs">S = randn(256, 256)
c = randn(256)
u = S*c;</code></pre><h2 id="Linear-Algebra"><a class="docs-heading-anchor" href="#Linear-Algebra">Linear Algebra</a><a id="Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra" title="Permalink"></a></h2><p>Different solvers require different interaction with the system matrix <span>$\mathbf{S}$</span>. Kaczmarz itself uses a dot product with the rows of <span>$\mathbf{S}$</span> and the current approximate solution <span>$\mathbf{c}$</span>. Since there is no predefined function for such an operation, RegularizedLeastSquares.jl implemented its own</p><pre><code class="language-julia hljs">using MPIReco.RegularizedLeastSquares
row = 1
isapprox(RegularizedLeastSquares.dot_with_matrix_row(S, c, row), sum(S[row, :] .* c))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Custom operators should implement efficient variants of this function to ensure good performance with the Kaczmarz solver. Since Julia is a column-major order language, this row-based access pattern is quite inefficient for dense arrays. A workaround is to transpose the matrix then pass it to a Kaczmarz solver.</p><pre><code class="language-julia hljs">S_efficient = transpose(collect(transpose(S)))
typeof(S_efficient)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearAlgebra.Transpose{Float64, Matrix{Float64}}</code></pre><p>RegularizedLeastSquares provides an efficient implmentation for this operator.</p><p>Other solvers such as FISTA or CGNR require the normal operator of <span>$\mathbf{S}$</span>, either because they require the gradient of the least squares norm or because the work on an adapted optimization problem. The normal operator <span>$\mathbf{S^*S}$</span> is composed of a matrix-vector product of <span>$\mathbf{S}$</span> followed by matrix-vector product of the adjoint of <span>$\mathbf{S}$</span>. An efficient matrix-vector product is provided in Julia by the LinearAlgebra standard library:</p><pre><code class="language-julia hljs">using LinearAlgebra
mul!(u, S, c)
isapprox(u, S * c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>This inplace variant of a matrix-vector product is used within in RegularizedLeastSquares and also needs to be provided for custom operators.</p><h2 id="Matrix-Free"><a class="docs-heading-anchor" href="#Matrix-Free">Matrix-Free</a><a id="Matrix-Free-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Free" title="Permalink"></a></h2><p>LinearAlgebra also provides a function to compute the adjoint of a matrix-vector product:</p><pre><code class="language-julia hljs">mul!(c, adjoint(S), u)
isapprox(c, adjoint(S) * u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>This function creates a lazy adjoint, i.e. it does not create a new array. Instead it only changes the way the size and indexing into the underyling array works.</p><pre><code class="language-julia hljs">S_adj = adjoint(S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">256×256 adjoint(::Matrix{Float64}) with eltype Float64:
 -0.214532   -0.701163    0.818321   …   0.366761   1.8675     -0.661719
  0.0978368  -1.95702    -0.328061       0.569062   0.209479   -0.645582
  0.728823    1.6005      2.51649        0.869746   0.725072    0.556189
  1.31219    -0.232912   -0.518936       0.841172   0.815161   -0.0186768
 -0.208535   -0.806822    0.716147       0.860731   0.556952    0.181689
 -0.830086   -0.400668   -0.614784   …  -1.39388   -0.850467   -0.937602
 -0.274826   -0.945309   -1.59314       -1.64677   -1.57767    -2.24875
  0.658534   -1.13649     0.369438      -1.14884    2.36967    -0.74793
 -0.102232   -0.0943485   1.09534       -1.2761    -1.31179     0.663639
  0.462511    0.555635   -0.20633       -1.10461    0.0605912   0.693075
  ⋮                                  ⋱                          ⋮
  1.07907     1.05636    -0.235461       0.325177   1.92544    -1.10424
  0.582706   -0.417526    0.576981      -0.653679   0.153447    0.199275
 -0.423917   -0.462088    0.0595521     -0.627748  -1.83826     1.24016
  0.0504218  -0.931995   -1.98542    …   0.558051  -0.6266      0.694563
  0.217049   -0.804512    0.0320035     -1.00347   -0.947126    0.931964
 -1.48566    -1.17447     0.609052      -2.16821    1.02349    -0.240487
  0.194436   -0.011205    0.932696      -1.03865   -0.734071    1.24642
 -0.175463   -0.287791   -0.720583      -0.571155  -0.458817    1.00813
  1.31721    -0.408626   -0.967537   …  -1.85911    1.08554     1.13689</code></pre><p>A related concepts are matrix-free operators. These are operators which behave like a matrix in a(n adjoint) matrix-vector product, but don&#39;t have an underlying dense matrix.</p><p>There are several different Julia packages with which one can create such matrix-free operators such as LinearOperators.jl or LinearMaps.jl. MPIReco uses the <a href="https://github.com/JuliaImageRecon/LinearOperatorCollection.jl">LinearOperatorCollection.jl</a> package to create matrix-free operators for and with <span>$\mathbf{S}$</span>.</p><pre><code class="language-julia hljs">using MPIReco.LinearOperatorCollection
weights = rand(256)
wop = WeightingOp(weights)
size(wop)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(256, 256)</code></pre><p>For example, LinearOperatorCollection provides a weighting operator. This operator acts as if it is a diagonal matrix, but only requires the elements of the diagonal. We can also do matrix-free matrix product to create <span>$\mathbf{WS}$</span> without calculating the matrix-matrix product:</p><pre><code class="language-julia hljs">WS = ProdOp(wop, S)
isapprox(WS * c, weights .* S * c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Another relevant matrix-free operator is the normal operator:</p><pre><code class="language-julia hljs">SHS = normalOperator(WS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Linear operator
  nrow: 256
  ncol: 256
  eltype: Float64
  symmetric: false
  hermitian: false
  nprod:   0
  ntprod:  0
  nctprod: 0

</code></pre><p>This operator not only computes its matrix-vector product in a lazy fashion, it also optimizes the resulting operator: Without an optimization a matrix-free product would apply the following operator each iteration:</p><p class="math-container">\[\begin{equation}
  (\mathbf{WS})^*\mathbf{WS} = \mathbf{S}^*\mathbf{W}^*\mathbf{W}\mathbf{S}
\end{equation}\]</p><p>This is not efficient and instead the normal operator can be optimized by initially computing the weights:</p><p class="math-container">\[\begin{equation}
  \tilde{\mathbf{W}} = \mathbf{W}^*\mathbf{W}
\end{equation}\]</p><p>and then applying the following each iteration:</p><p class="math-container">\[\begin{equation}
  \mathbf{S}^*\tilde{\mathbf{W}}\mathbf{S}
\end{equation}\]</p><p>And lastly, the efficient multi-patch image reconstruction is based on a matrix-free multi-patch operator. This operator contains system matrices per patch as well as indexing metadata and is able to act like a large dense matrix in a matrix-vector product and can be combined with weighting and the normal operator.</p><h2 id="GPU-Acceleration"><a class="docs-heading-anchor" href="#GPU-Acceleration">GPU Acceleration</a><a id="GPU-Acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Acceleration" title="Permalink"></a></h2><p>GPU acceleration is achieved by adapting <span>$\mathbf{S}$</span> and <span>$\mathbf{u}$</span> to be GPU-compatible data types. In the case of dense arrays, this means the arrays are GPU arrays.</p><p>Matrix-free operators on the other hand don&#39;t necessarily need to be on the GPU. In the case that a matrix-free operator is only a function call, this function only needs to be GPU compatible. In the case of the weighting operator or the matrix-free operator, we need to move the internally used dense arrays to the GPU and can then use them on the GPU.</p><p>To make more complex operators work on the GPU one can either try to formulate a method on GPUArrays which only uses broadcasts. Or alternatively implement a custom GPU kernel with either a specific GPU package such as CUDA.jl or AMDGPU.jl or a vendor-agnostic kernel using KernelAbstractions.jl.</p><p>A related Julia package is also the <a href="https://github.com/JuliaGPU/Adapt.jl">Adapt.jl</a>, which offers the <code>adapt</code> method. This essentially acts like <code>convert(T, a)</code> without the restriction that the result must be of type T. The use case for GPU computing here is to provide the GPU array type T and then return a GPU compatibe version of <code>a</code>, however that might look like.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../recoplans/">« MPIRecoPlan</a><a class="docs-footer-nextpage" href="../../../references/utility/">Utility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 7 August 2025 09:30">Thursday 7 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
