var documenterSearchIndex = {"docs":
[{"location":"datasetStore.html#Layers","page":"-","title":"Layers","text":"","category":"section"},{"location":"datasetStore.html","page":"-","title":"-","text":"The reconstruction function has several layers starting from a high level over several middle layer to low layer functions. The most high level method has the following signature `julia reconstruction(dMDFDatasetStore studyStudy expExperiment recoParamsDictStringAny)","category":"page"},{"location":"multiContrast.html#Multi-Contrast-Reconstruction","page":"Multi-Contrast","title":"Multi-Contrast Reconstruction","text":"","category":"section"},{"location":"multiContrast.html","page":"Multi-Contrast","title":"Multi-Contrast","text":"Until now we have discussed single-contrast reconstruction in which case the reconstructed image c has a singleton first dimension. To perform multi-contrast reconstruction one has to specify multiple system matrices","category":"page"},{"location":"multiContrast.html","page":"Multi-Contrast","title":"Multi-Contrast","text":"bSFa = MPIFile(filenameA)\nbSFb = MPIFile(filenameB)","category":"page"},{"location":"multiContrast.html","page":"Multi-Contrast","title":"Multi-Contrast","text":"and can then invoke","category":"page"},{"location":"multiContrast.html","page":"Multi-Contrast","title":"Multi-Contrast","text":"c = reconstruction([bSFa, bSFb], b;\n                    SNRThresh=5, frames=1, minFreq=80e3,\n                    recChannels=1:2, iterations=1)","category":"page"},{"location":"multiContrast.html","page":"Multi-Contrast","title":"Multi-Contrast","text":"Now one can access the first and second channel by c[1,:,:,:] and c[2,:,:,:].","category":"page"},{"location":"multiPatch.html#Multi-Patch-Reconstruction","page":"Multi-Patch","title":"Multi-Patch Reconstruction","text":"","category":"section"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"For multi-patch reconstruction the method proposed by Szwargulski et al. is implemented in MPIReco. It is generalized however.","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"We first discuss the measurements for the multi-patch case. On modern MPI scanners the BrukerFile or MDFFile can be used as is. However, the data that we use in our unit tests consists of several single-patch measurements. to combine these measurements we call","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"b = MultiMPIFile([\"dataMP01\", \"dataMP02\", \"dataMP03\", \"dataMP04\"])","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"b now can be uses as if were a multi-patch file.","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"Now we get to the system matrix. The most simple approach is to use a single system matrix that was measured at the center. This can be done using","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"bSF = MultiMPIFile([\"SF_MP\"])\n\nc = reconstruction(bSF, b; SNRThresh=5, frames=1, minFreq=80e3,\n                   recChannels=1:2, iterations=1, spectralLeakageCorrection=false)","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"The reconstruction parameters are not special here but are the same as discussed in the Parameters section.","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"It is also possible to use multiple system matrices, which is currently the best way to take field imperfection into account. Our test data has four patches and we therefore can use","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"bSF = MultiMPIFile([\"SF_MP01\", \"SF_MP02\", \"SF_MP03\", \"SF_MP04\"])\n\nc = reconstruction(bSF, b; SNRThresh=5, frames=1, minFreq=80e3,\n                   recChannels=1:2, iterations=1, spectralLeakageCorrection=false)","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"Now we want somewhat more flexibility and","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"define a mapping between the system matrix and the patches, here we allow to use the same system matrix for multiple patches\nmake it possible to change the FFP position. Usually the value stored in the file is not 100% correct due to field imperfections.\nwe might also want to preload the system matrices","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"All those thing can be done as is shown in the following example","category":"page"},{"location":"multiPatch.html","page":"Multi-Patch","title":"Multi-Patch","text":"bSFs = MultiMPIFile([\"SF_MP01\", \"SF_MP02\", \"SF_MP03\", \"SF_MP04\"])\nmapping = [1,2,3,4]\nfreq = filterFrequencies(bSFs, SNRThresh=5, minFreq=80e3)\nS = [getSF(SF,freq,nothing,\"kaczmarz\", bgcorrection=false)[1] for SF in bSFs]\nSFGridCenter = zeros(3,4)\nFFPos = zeros(3,4)\nFFPos[:,1] = [-0.008, 0.008, 0.0]\nFFPos[:,2] = [-0.008, -0.008, 0.0]\nFFPos[:,3] = [0.008, 0.008, 0.0]\nFFPos[:,4] = [0.008, -0.008, 0.0]\nc4 = reconstruction(bSFs, b; SNRThresh=5, frames=1, minFreq=80e3,\n        recChannels=1:2,iterations=1, spectralLeakageCorrection=false,\n        mapping=mapping, systemMatrices = S, SFGridCenter=SFGridCenter,\n        FFPos=FFPos, FFPosSF=FFPos)","category":"page"},{"location":"overview.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"In order to get started we will first gather some MPI data. To this end we enter the Pkg mode in Julia (]) and execute the unit tests of MPIReco","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"test MPIReco","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"Now there will be several MPI files in the test directory. All the following examples assume that you entered the test directory and loaded MPIReco using","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"using MPIReco\ncd(joinpath(dirname(pathof(MPIReco)),\"..\",\"test\"))","category":"page"},{"location":"overview.html#First-Reconstruction","page":"Getting Started","title":"First Reconstruction","text":"","category":"section"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"We will start looking at a very basic reconstruction script","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"using MPIReco\n\nfSF = MPIFile(\"SF_MP\")\nf = MPIFile(\"dataMP01\")\n\nc = reconstruction(fSF, f;\n                   SNRThresh=5,\n                   frames=1:10,\n                   minFreq=80e3,\n                   recChannels=1:2,\n                   iterations=1,\n                   spectralLeakageCorrection=true)\n","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"Lets go through that script step by step. First, we create handles for the system matrix and the measurement data. Both are of the type MPIFile which is an abstract type that can for instance be an MDFFile or a BrukerFile.","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"Using the handles to the MPI datasets we can call the reconstruction function that has various variants depending on the types that are passed to it. Here, we exploit the multiple dispatch mechanism of julia. In addition to the file handles we also apply several reconstruction parameters using keyword arguments. In this case, we set the SNR threshold to 5 implying that only matrix rows with an SNR above 5 are used during reconstruction. The parameter frame decides which frame of the measured data should be reconstructed.","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"The object c is of type ImageMeta and contains not only the reconstructed data but also several metadata such as the reconstruction parameters being used. More details on the return type are discussed in the Reconstruction Results","category":"page"},{"location":"overview.html#Data-Storage","page":"Getting Started","title":"Data Storage","text":"","category":"section"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"One can store the reconstruction result into an MDF file by calling","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"saveRecoData(\"filename.mdf\", c)","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"In order to load the data one calls","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"c = loadRecoData(\"filename.mdf\", c)","category":"page"},{"location":"overview.html","page":"Getting Started","title":"Getting Started","text":"We will next take a closer look at different forms of the reconstruction routine.","category":"page"},{"location":"recoResults.html#Reconstruction-Results","page":"Results","title":"Reconstruction Results","text":"","category":"section"},{"location":"recoResults.html","page":"Results","title":"Results","text":"The object c is of type ImageMeta and contains not only the reconstructed data but also several metadata such as the reconstruction parameters being used. c has in total 5 dimensions. The first dimension encodes multi-spectral channels. Dimensions 2-4 encode the three spatial dimensions. The last dimension contains the number of frames being stored in c.","category":"page"},{"location":"basicReconstruction.html#Basic-Reconstruction","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"","category":"section"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"MPIReco.jl provides different reconstruction levels. All of these reconstruction routines are called reconstruction and the dispatch is done based on the input types.","category":"page"},{"location":"basicReconstruction.html#On-Disk-Reconstruction","page":"Basic Reconstruction","title":"On Disk Reconstruction","text":"","category":"section"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"This is the highest level reconstruction. The function signature is given by","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(d::MDFDatasetStore, study::Study,\n                        exp::Experiment, recoParams::Dict)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"This reconstruction is also called an on disk reconstruction because it assumes that one has a data store (i.e. a structured folder of files) where the file location is uniquely determined by the study name and experiment number. All reconstruction parameters are passed to this method by the recoParams dictionary. On disk reconstruction has the advantage that the routine will perform reconstruction only once for a particular set of parameters. If that parameter set has already been reconstructed, the data will loaded from disk. However, the on disk reconstruction needs some experience with dataset stores to set it up correctly and is not suited for unstructured data.","category":"page"},{"location":"basicReconstruction.html#In-Memory-Reconstruction","page":"Basic Reconstruction","title":"In Memory Reconstruction","text":"","category":"section"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"The next level is the in memory reconstruction. Its function signature reads","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(recoParams::Dict)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"This routine requires that all parameters are put into a dictionary. An overview how this dictionary looks like is given in the section Parameters.","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"The above reconstruction method basically does two things","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"Pull out the location of measurement data and system matrix from the recoParams dictionary.\nPass all parameter to the low level reconstruction method in the form of keyword parameters.","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"In turn the next level reconstruction looks like this","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(bSF::MPIFile, bMeas::MPIFile; kargs...)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"There are, however also some reconstruction methods in-between that look like this","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(filenameSF::AbstractString, filenameMeas::AbstractString; kargs...)\nfunction reconstruction(filenameMeas::AbstractString; kargs...)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"In both cases, an MPIFile is created based on the input filename. The second version also guesses the system matrix based on what is stored within the measurement file. This usually only works, if this is executed on a system where the files are stored at exactly the same location as how they have been measured.","category":"page"},{"location":"basicReconstruction.html#Middle-Level-Reconstruction","page":"Basic Reconstruction","title":"Middle Level Reconstruction","text":"","category":"section"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"The middle level reconstruction first checks, whether the dataset is a multi-patch or a single-patch file. Then it will call either reconstructionSinglePatch or reconstructionMultiPatch. Both have essentially the signature","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstructionSinglePatch(bSF::MPIFile, bMeas::MPIFile;\n                                  minFreq=0, maxFreq=1.25e6, SNRThresh=-1,\n                                  maxMixingOrder=-1, numUsedFreqs=-1, sortBySNR=false, recChannels=1:numReceivers(bMeas),\n                                  bEmpty = nothing, bgFrames = 1, fgFrames = 1,\n                                  varMeanThresh = 0, minAmplification=2, kargs...)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"Here, one can see various parameters that can be used to control, which frequency components are being used for reconstruction. All these parameters are passed to the filterFrequencies function from MPIFiles.jl.","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"The function reconstructionSinglePatch performs the frequency filtering and then calls","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(bSF::MPIFile, bMeas::MPIFile, freq::Array;\n  bEmpty = nothing, bgFrames = 1,  denoiseWeight = 0, redFactor = 0.0, thresh = nothing,\n  loadasreal = false, solver = \"kaczmarz\", sparseTrafo = nothing, saveTrafo=false,\n  gridsize = gridSizeCommon(bSF), fov=calibFov(bSF), center=[0.0,0.0,0.0], useDFFoV=false,\n  deadPixels=Int[], bgCorrectionInternal=false, kargs...)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"One can see that the frequency index is passed to this function as the third argument. All new keyword arguments are essentially used for determining the way how the system matrix is loaded. For instance with the parameters gridsize, fov, center it is possible to change the grid at which the system function is being loaded.","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"Once the system matrix is loaded, the next lower level function is called:","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(S, bSF::MPIFile, bMeas::MPIFile, freq::Array, grid;\n  frames = nothing, bEmpty = nothing, bgFrames = 1, nAverages = 1, numAverages=nAverages,\n  sparseTrafo = nothing, loadasreal = false, maxload = 100, maskDFFOV=false,\n  weightType=WeightingType.None, weightingLimit = 0, solver = \"kaczmarz\",\n  spectralCleaning=true, fgFrames=1:10, bgCorrectionInternal=false,\n  noiseFreqThresh=0.0, kargs...)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"This function is responsible for loading the measurement data and potential background data that is subtracted from the measurements. For any frame to be reconstructed, the low level reconstruction routine is called.","category":"page"},{"location":"basicReconstruction.html#Low-Level-Reconstruction","page":"Basic Reconstruction","title":"Low Level Reconstruction","text":"","category":"section"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"Finally, we have arrived at the low level reconstruction routine that has the signature","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"function reconstruction(S, u::Array; sparseTrafo = nothing,\n                        lambd=0, progress=nothing, solver = \"kaczmarz\",\n                        weights=nothing, kargs...)","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"One can see that it requires the system matrix S and the measurements u to be already loaded.","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"We note that S is typeless for a reason here. For a regular reconstruction one will basically feed in an Array{ComplexF32,2} in here, although more precisely it will be a Transposed version of that type if the Kaczmarz algorithm is being used for efficiency reasons.","category":"page"},{"location":"basicReconstruction.html","page":"Basic Reconstruction","title":"Basic Reconstruction","text":"However, in case that matrix compression is applied S will be of type SparseMatrixCSC. And for Multi-Patch Reconstruction S will be of type MultiPatchOperator. Hence, the solvers are implemented in a very generic way and require only certain functions to be implemented. The low level reconstruction method calls one of the solvers from RegularizedLeastSquares.jl.","category":"page"},{"location":"index.html#MPIReco.jl","page":"Home","title":"MPIReco.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Julia package for the reconstruction of magnetic particle imaging (MPI) data","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This project provides functions for the reconstruction of MPI data. The project is implemented in the programming language Julia and contains algorithms for","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Basic Reconstruction using a system matrix based approach\nMulti-Patch Reconstruction for data that has been acquired using a focus field sequence\nMulti-Contrast Reconstruction\nMatrix-Compression Techniques","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Key features are","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Frequency filtering for memory efficient reconstruction. Only frequencies used during reconstructions are loaded into memory.\nDifferent solvers provided by the package RegularizedLeastSquares.jl\nHigh-level until low-level reconstruction providing maximum flexibility for the user\nSpectral leakage correction (implemented in MPIFiles.jl)","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"add MPIReco","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will install the packages MPIReco.jl and all its dependencies. In particular this will install the core dependencies MPIFiles and RegularizedLeastSquares.","category":"page"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"index.html#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tobias Knopp\nMartin Möddel\nPatryk Szwargulski","category":"page"},{"location":"matrixCompression.html#Matrix-Compression-Techniques","page":"Compression","title":"Matrix-Compression Techniques","text":"","category":"section"},{"location":"matrixCompression.html","page":"Compression","title":"Compression","text":"The reconstruction can be accelerated by applying matrix compression. To this end, the system matrix S is transformed into a different domain by applying a  basis transformation on the rows of the system matrix. In MPIReco.jl, matrix compression can be enabled by specifying sparseTrafo which can be \"DCT-IV\" or \"FFT\". ","category":"page"},{"location":"matrixCompression.html","page":"Compression","title":"Compression","text":"The transformations can be restricted to the drive-field field-of-view by setting useDFFoV = true. The compression factor that controls how many coefficients are dropped after application of the transformation is controlled by the parameter redFactor. For instance a reduction factor of redFactor = 0.01 will drop 99 % of the data.","category":"page"},{"location":"parameters.html#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"}]
}
