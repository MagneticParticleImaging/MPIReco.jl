var documenterSearchIndex = {"docs":
[{"location":"generated/tutorials/weighting/#Weighting","page":"Weighting","title":"Weighting","text":"","category":"section"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"Often time it is benefical to consider a weighted least squares problem of the form:","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"beginequation\n  undersetmathbfxargmin frac12vertvert mathbfSmathbfc-mathbfu vertvert^2_mathbfW + mathbfR(u) \nendequation","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"where mathbfW is a symmetric, positive weighting matrix and vertvertmathbfyvertvert^2_mathbfW denotes the weighted Euclidean norm.","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"MPIReco provides several different weighting strategies and new strategies can easily be added and plugged into existing algorithms. An example of how to implement such a strategy is shown in the How-Tos. For an overview of the available strategy consult the API reference.","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"using MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")) #hide\nparams = Dict{Symbol, Any}()\nparams[:SNRThresh] = 5\nparams[:frames] = 1:1\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:2\nparams[:spectralLeakageCorrection] = true\nparams[:sf] = bSF\nparams[:reg] = [L2Regularization(0.1f0)];\nnothing #hide","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"To apply different strategies, we simply swap out the weightingParams of our single-patch algorithm.","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"cChannel = reconstruct(\"SinglePatch\", b; params..., weightingParams = ChannelWeightingParameters([0.8, 0.2]))\ncRow = reconstruct(\"SinglePatch\", b; params..., weightingParams = RowNormWeightingParameters())\ncWhite = reconstruct(\"SinglePatch\", b; params..., weightingParams = WhiteningWeightingParameters(whiteningMeas = bSF));\nnothing #hide","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"We will again visualize the reconstructions with CairoMakie:","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"using CairoMakie #hide\nfig = Figure();\nhidedecorations!(heatmap(fig[1, 1], cChannel[1, :, :, 1, 1].data.data, axis = (title = \"Channel\",)).axis)\nhidedecorations!(heatmap(fig[1, 2], cRow[1, :, :, 1, 1].data.data, axis = (title = \"Row Norm\",)).axis)\nhidedecorations!(heatmap(fig[1, 3], cWhite[1, :, :, 1, 1].data.data, axis = (title = \"Whitening\",)).axis)\nfig","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"","category":"page"},{"location":"generated/tutorials/weighting/","page":"Weighting","title":"Weighting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/gpuAcceleration/#GPU-Acceleration","page":"GPU-Acceleration","title":"GPU Acceleration","text":"","category":"section"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"include(\"../../download.jl\") #hide\ngpu = Array; #hide\nnothing #hide","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"MPIReco supports generic GPU acceleration. This means that the user can use any GPU array type that supports the GPUArrays interface. This includes CUDA.jl, AMDGPU.jl, and Metal.jl. To perform a reconstruction on the GPU, one has to load a GPU backend package such as CUDA and specify the GPU array type:","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"using CUDA\ngpu = CuArray","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"Afterwards one can use the normal reconstruction interface and specify the arrayType parameter. However, the default solver is Kaczmarz, which has poor GPU performance. One should instead use CGNR or other solver. Since those solvers usually converge slower, one also has to increase the number of iterations","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"using MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")) #hide\nparams = Dict{Symbol, Any}()\nparams[:SNRThresh] = 5\nparams[:frames] = 1:1\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:2\nparams[:spectralLeakageCorrection] = true\nparams[:sf] = bSF\nparams[:weightingParams] = WhiteningWeightingParameters(whiteningMeas = bSF)\nparams[:reg] = [L2Regularization(0.1f0)]","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"Specifying the GPU array type to use, allows reconstruction algorithm to move the system matrix and data to the GPU after frequency filtering:","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"c = reconstruct(\"SinglePatch\", b; params..., arrayType = gpu, iterations = 100, solver = CGNR);\nnothing #hide","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"The resulting image is moved to the CPU at the end of the reconstruction and is accessible like any other reconstruction:","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"using CairoMakie\nfig = heatmap(c[1, :, :, 1, 1].data.data)\nhidedecorations!(fig.axis)\nfig","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"","category":"page"},{"location":"generated/tutorials/gpuAcceleration/","page":"GPU-Acceleration","title":"GPU-Acceleration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/howtos/solvers/#Change-and-Configure-Solvers","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"","category":"section"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"include(\"../../download.jl\") #hide\nusing MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")); #hide\nnothing #hide","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"MPIReco uses RegularizedLeastSquares.jl as its optimization backend. As such it can use any of the solvers and regularization terms defined for and in RegularizedLeastSquares.","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"In general, RegularizedLeastSquares aims to solve problems of the form:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"beginequation\n  undersetmathbfcargmin frac12vertvert mathbfSmathbfc-mathbfu vertvert_2^2 + + mathbfR(x)\nendequation","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"where mathbfS is a system matrix operator and mathbfu is the measurement vector. Both are provided by MPIReco and constructed based on the specific parameters and processing steps of a given reconstruction algorithm. The (optional) regularization term mathbfR(x) can be used to encode additional prior information about the inverse problem. Different solvers of RegularizedLeastSquares can work with different regularization terms. For example, the Kaczmarz and CGNR solver are defined for the l^2_2-norm. More information on available solvers and regularization terms can be found RegularizedLeastSquares documentation.","category":"page"},{"location":"generated/howtos/solvers/#Solver-and-Solver-Parameters","page":"Change and Configure Solvers","title":"Solver and Solver Parameters","text":"","category":"section"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"MPIReco offers different ways to configure the used solvers, similar to how it for example offers different weighting strategies. If we take a look at the default solver parameters from the single-patch reconstruction:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"plan = MPIRecoPlan(\"SinglePatch\")\nsolverParams = plan.parameter.reco.solverParams","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"We see that the default parameters are of type ElaborateSolverParameters. These are a special set of parameters, because they contain the union of all solver parameters defined in RegularizedLeastSquares. The current selection of parameters changes based on the selected solver:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"solverParams.solver = Kaczmarz\nsolverParams","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"or:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"solverParams.solver = FISTA\nsolverParams","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"With these parameters we can define both the solver and the solver parameters as defined in RegularizedLeastSquares.","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"It is also possible to add new solvers, such as variants of existing solver specialised for MPI. To do this, we have to implement a new solver variant for RegularizedLeastSquares. We can either implement a new solver or implement a new variant of a solver via its state:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"using MPIReco.RegularizedLeastSquares\nmutable struct OurSolver{OP, T} <: RegularizedLeastSquares.AbstractLinearSolver\n  S::OP\n  c::Vector{T}\n  u::Vector{T}\n  notification::String\nend\nfunction OurSolver(S; notification = \"Test\", kwargs...)\n  u = zeros(eltype(S), size(S, 1))\n  c = zeros(eltype(S), size(S, 2))\n  return OurSolver(S, c, u, notification)\nend\nfunction RegularizedLeastSquares.init!(solver::OurSolver{OP, T}, u) where {OP, T}\n  solver.u .= u\n  solver.c .= zero(T)\nend\nfunction Base.iterate(solver::OurSolver)\n  @info solver.notification\n  solver.c .= solver.S \\ solver.u\n  return nothing\nend\nRegularizedLeastSquares.solversolution(solver::OurSolver) = solver.c","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"Afterwards, we can just use the solver type as usual:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"params = Dict{Symbol, Any}()\nparams[:SNRThresh] = 5\nparams[:frames] = 1:1\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:2\nparams[:spectralLeakageCorrection] = true\nparams[:sf] = bSF;\n\nc = reconstruct(\"SinglePatch\", b; params..., solver = OurSolver)\nusing CairoMakie #hide\nfig = heatmap(c[1, :, :, 1, 1].data.data)\nhidedecorations!(fig.axis)\nfig","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"If our custom solver requires custom parameters, we could implement custom solver parameters in MPIReco:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"Base.@kwdef struct OurSolverParameters <: MPIReco.AbstractSolverParameters{OurSolver}\n  notification::String\n  enforceReal::Bool=true\n  enforcePositive::Bool=true\nend\nreconstruct(\"SinglePatch\", b; params..., solverParams = OurSolverParameters(notification = \"Custom\"));\nnothing #hide","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"More on custom parameters for MPIReco can be found in Custom Data Processing and Algorithms.","category":"page"},{"location":"generated/howtos/solvers/#Regularization-Term","page":"Change and Configure Solvers","title":"Regularization Term","text":"","category":"section"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"RegularizedLeastSquares allows for the generartion of flexible regularization using a vector of (nested) regularization terms. By providing such a vector, we can configure the regularization term similar to the solver:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"setAll!(plan, :reg, [L2Regularization(0.1)])","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"Because MPI oftens constrain its solutions to positive, real numbers, MPIReco offers some shortcurts to enable/disable these constraints:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"setAll!(plan, :enforceReal, true)","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"Internally, these are just additional regularization terms added to the provided regularization terms. For more complex regularization examples, take a look at the RegularizedLeastSquares documentation.","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"To implement a custom regularization we have to implement a proximal mapping:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"beginequation\n  prox_g (mathbfx) = undersetmathbfuargmin frac12vertvert mathbfu-mathbfx vert vert^2 + g(mathbfx)\nendequation","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"For many regularizers, the proximal map can be computed efficiently in a closed form.","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"In order to implement these proximal mappings, we have to defines the following type functions for our new proximal map:","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"abstract type AbstractRegularization\nprox!(reg::AbstractRegularization, x)\nnorm(reg::AbstractRegularization, x)","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"Here prox!(reg, x) is an in-place function which computes the proximal map on the input-vector x. The function norm computes the value of the corresponding term in the inverse problem. RegularizedLeastSquares.jl provides AbstractParameterizedRegularization and AbstractProjectionRegularization as core regularization types.","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"","category":"page"},{"location":"generated/howtos/solvers/","page":"Change and Configure Solvers","title":"Change and Configure Solvers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/explanations/operators/#Imaging-Operators","page":"Imaging Operators","title":"Imaging Operators","text":"","category":"section"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"using MPIReco #hide","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"The system-matrix based image reconstruction algorithms provided by MPIReco mainly focus on inverse problems of the form:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"beginequation\n  undersetmathbfcargmin frac12vertvert mathbfSmathbfc-mathbfu vertvert_2^2 + + mathbfR(x)\nendequation","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"where mathbfS is a system matrix, mathbfu is the measurement vector, and mathbfR(x) is an (optional) regularization term. In this explanation we will take a closer look at the requirements on mathbfS, which is especially relevant if one wants to implement a hybrid- or model based operator for the inverse problem.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"S = randn(256, 256)\nc = randn(256)\nu = S*c;\nnothing #hide","category":"page"},{"location":"generated/explanations/operators/#Linear-Algebra","page":"Imaging Operators","title":"Linear Algebra","text":"","category":"section"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Different solvers require different interaction with the system matrix mathbfS. Kaczmarz itself uses a dot product with the rows of mathbfS and the current approximate solution mathbfc. Since there is no predefined function for such an operation, RegularizedLeastSquares.jl implemented its own","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"using MPIReco.RegularizedLeastSquares\nrow = 1\nisapprox(RegularizedLeastSquares.dot_with_matrix_row(S, c, row), sum(S[row, :] .* c))","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Custom operators should implement efficient variants of this function to ensure good performance with the Kaczmarz solver. Since Julia is a column-major order language, this row-based access pattern is quite inefficient for dense arrays. A workaround is to transpose the matrix then pass it to a Kaczmarz solver.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"S_efficient = transpose(collect(transpose(S)))\ntypeof(S_efficient)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"RegularizedLeastSquares provides an efficient implmentation for this operator.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Other solvers such as FISTA or CGNR require the normal operator of mathbfS, either because they require the gradient of the least squares norm or because the work on an adapted optimization problem. The normal operator mathbfS^*S is composed of a matrix-vector product of mathbfS followed by matrix-vector product of the adjoint of mathbfS. An efficient matrix-vector product is provided in Julia by the LinearAlgebra standard library:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"using LinearAlgebra\nmul!(u, S, c)\nisapprox(u, S * c)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"This inplace variant of a matrix-vector product is used within in RegularizedLeastSquares and also needs to be provided for custom operators.","category":"page"},{"location":"generated/explanations/operators/#Matrix-Free","page":"Imaging Operators","title":"Matrix-Free","text":"","category":"section"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"LinearAlgebra also provides a function to compute the adjoint of a matrix-vector product:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"mul!(c, adjoint(S), u)\nisapprox(c, adjoint(S) * u)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"This function creates a lazy adjoint, i.e. it does not create a new array. Instead it only changes the way the size and indexing into the underyling array works.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"S_adj = adjoint(S)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"A related concepts are matrix-free operators. These are operators which behave like a matrix in a(n adjoint) matrix-vector product, but don't have an underlying dense matrix.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"There are several different Julia packages with which one can create such matrix-free operators such as LinearOperators.jl or LinearMaps.jl. MPIReco uses the LinearOperatorCollection.jl package to create matrix-free operators for and with mathbfS.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"using MPIReco.LinearOperatorCollection\nweights = rand(256)\nwop = WeightingOp(weights)\nsize(wop)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"For example, LinearOperatorCollection provides a weighting operator. This operator acts as if it is a diagonal matrix, but only requires the elements of the diagonal. We can also do matrix-free matrix product to create mathbfWS without calculating the matrix-matrix product:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"WS = ProdOp(wop, S)\nisapprox(WS * c, weights .* S * c)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Another relevant matrix-free operator is the normal operator:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"SHS = normalOperator(WS)","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"This operator not only computes its matrix-vector product in a lazy fashion, it also optimizes the resulting operator: Without an optimization a matrix-free product would apply the following operator each iteration:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"beginequation\n  (mathbfWS)^*mathbfWS = mathbfS^*mathbfW^*mathbfWmathbfS\nendequation","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"This is not efficient and instead the normal operator can be optimized by initially computing the weights:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"beginequation\n  tildemathbfW = mathbfW^*mathbfW\nendequation","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"and then applying the following each iteration:","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"beginequation\n  mathbfS^*tildemathbfWmathbfS\nendequation","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"And lastly, the efficient multi-patch image reconstruction is based on a matrix-free multi-patch operator. This operator contains system matrices per patch as well as indexing metadata and is able to act like a large dense matrix in a matrix-vector product and can be combined with weighting and the normal operator.","category":"page"},{"location":"generated/explanations/operators/#GPU-Acceleration","page":"Imaging Operators","title":"GPU Acceleration","text":"","category":"section"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"GPU acceleration is achieved by adapting mathbfS and mathbfu to be GPU-compatible data types. In the case of dense arrays, this means the arrays are GPU arrays.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"Matrix-free operators on the other hand don't necessarily need to be on the GPU. In the case that a matrix-free operator is only a function call, this function only needs to be GPU compatible. In the case of the weighting operator or the matrix-free operator, we need to move the internally used dense arrays to the GPU and can then use them on the GPU.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"To make more complex operators work on the GPU one can either try to formulate a method on GPUArrays which only uses broadcasts. Or alternatively implement a custom GPU kernel with either a specific GPU package such as CUDA.jl or AMDGPU.jl or a vendor-agnostic kernel using KernelAbstractions.jl.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"A related Julia package is also the Adapt.jl, which offers the adapt method. This essentially acts like convert(T, a) without the restriction that the result must be of type T. The use case for GPU computing here is to provide the GPU array type T and then return a GPU compatibe version of a, however that might look like.","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"","category":"page"},{"location":"generated/explanations/operators/","page":"Imaging Operators","title":"Imaging Operators","text":"This page was generated using Literate.jl.","category":"page"},{"location":"recoResults/#Reconstruction-Results","page":"Reconstruction Results","title":"Reconstruction Results","text":"","category":"section"},{"location":"recoResults/","page":"Reconstruction Results","title":"Reconstruction Results","text":"The object c is of type ImageMeta and contains not only the reconstructed data but also several metadata such as the reconstruction parameters being used. c has in total 5 dimensions. The first dimension encodes multi-spectral channels. Dimensions 2-4 encode the three spatial dimensions. The last dimension contains the number of frames being stored in c.","category":"page"},{"location":"literate/lowlevel/","page":"-","title":"-","text":"Finally, we have arrived at the low level reconstruction routine that has the signature","category":"page"},{"location":"literate/lowlevel/","page":"-","title":"-","text":"function reconstruction(S, u::Array; sparseTrafo = nothing,\n                        lambd=0, progress=nothing, solver = \"Kaczmarz\",\n                        weights=nothing, kargs...)","category":"page"},{"location":"literate/lowlevel/","page":"-","title":"-","text":"One can see that it requires the system matrix S and the measurements u to be already loaded.","category":"page"},{"location":"literate/lowlevel/","page":"-","title":"-","text":"We note that S is typeless for a reason here. For a regular reconstruction one will basically feed in an Array{ComplexF32,2} in here, although more precisely it will be a Transposed version of that type if the Kaczmarz algorithm is being used for efficiency reasons.","category":"page"},{"location":"literate/lowlevel/","page":"-","title":"-","text":"However, in case that matrix compression is applied S will be of type SparseMatrixCSC. And for Multi-Patch Reconstruction S will be of type MultiPatchOperator. Hence, the solvers are implemented in a very generic way and require only certain functions to be implemented. The low level reconstruction method calls one of the solvers from RegularizedLeastSquares.jl.","category":"page"},{"location":"generated/tutorials/multiPatch/#Multi-Patch-Reconstruction","page":"Multi-Patch","title":"Multi-Patch Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"For multi-patch reconstruction the method proposed by Szwargulski et al. is implemented in MPIReco. It is generalized however as described in Boberg et al..","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"We first discuss the measurements for the multi-patch case. On modern MPI scanners the BrukerFile or MDFFile can be used as is. However, the data that we use in our unit tests consists of several single-patch measurements. We therefore combine them manually into an MultiMPIFile:","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"using MPIReco #hide\nfiles = [\"1.mdf\", \"2.mdf\", \"3.mdf\", \"4.mdf\"]\nb = MultiMPIFile(joinpath.(datadir, \"measurements\", \"20211226_203916_MultiPatch\", files))","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"And now b can be used as if it was a multi-patch file.","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"Next we take a look at the system matrix. The most simple approach is to use a single system matrix that was measured at the center. This can be done using","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"bSF = MultiMPIFile([joinpath(datadir, \"calibrations\", \"12.mdf\")])","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"Afterwards we can perform a reconstruction with","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"c1 = reconstruct(\"MultiPatch\", b; sf = bSF, SNRThresh=5, frames=1:acqNumFrames(b), minFreq=80e3,\n                   recChannels=1:rxNumChannels(b), iterations=1, spectralLeakageCorrection=false, tfCorrection = false);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"The parameters are essentially the same as in the previous reconstructions, we only change the algorithm and the MPIFiles.","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"It is also possible to use multiple system matrices, which is currently the best way to take field imperfection into account. Our test data has four patches and we therefore can use","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"sf_files =  [\"8.mdf\", \"9.mdf\", \"10.mdf\", \"11.mdf\"]\nbSFs = MultiMPIFile(joinpath.(datadir, \"calibrations\", sf_files))\n\nc2 = reconstruct(\"MultiPatch\", b; sf = bSFs, SNRThresh=5, frames=1:acqNumFrames(b), minFreq=80e3,\n                   recChannels=1:rxNumChannels(b), iterations=1, spectralLeakageCorrection=false, tfCorrection = false);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"Now we want somewhat more flexibility and","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"define a mapping between the system matrix and the patches, here we allow to use the same system matrix for multiple patches\nmake it possible to change the FFP position. Usually the value stored in the file is not 100% correct due to field imperfections.","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"To achieve this, we swap out parts of the MultiPatch blueprint with a parameter which allows us to explicitly set all these parameters","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"We perform our own frequency filtering.","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"freq = filterFrequencies(bSFs, SNRThresh=5, minFreq=80e3);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"And load four different system matrices for each patch.","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"S = [getSF(SF,freq,nothing,\"Kaczmarz\", bgcorrection=false, tfCorrection = false)[1] for SF in bSFs]","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"Afterwards we can describe our patch mapping and positions:","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"mapping = [1,2,3,4]\nSFGridCenter = zeros(3,4)\nFFPos = zeros(3,4)\nFFPos[:,1] = [-0.008, 0.008, 0.0]\nFFPos[:,2] = [-0.008, -0.008, 0.0]\nFFPos[:,3] = [0.008, 0.008, 0.0]\nFFPos[:,4] = [0.008, -0.008, 0.0];\nnothing #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"Lastly, we wrap everything in a parameter structs:","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"opParams = ExplicitMultiPatchParameter(;tfCorrection = false, systemMatrices = S, SFGridCenter = SFGridCenter, mapping = mapping)\nffPos = CustomFocusFieldPositions(FFPos);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"and perform our reconstruction:","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"c3 = reconstruct(\"MultiPatch\", b; sf = bSFs, opParams = opParams, ffPos = ffPos, ffPosSF = ffPos,\n                  SNRThresh=5, frames=1:acqNumFrames(b), minFreq=80e3,\n                  recChannels=1:rxNumChannels(b), iterations=1, spectralLeakageCorrection=false, tfCorrection = false);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"We can again visualize our different multi-patch reconstructions:","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"using CairoMakie #hide\nfig = Figure();\nhidedecorations!(heatmap(fig[1, 1], c1[1, :, :, 1, 1].data.data, axis = (title = \"Single SM\",)).axis)\nhidedecorations!(heatmap(fig[1, 2], c2[1, :, :, 1, 1].data.data, axis = (title = \"Multiple SM\",)).axis)\nhidedecorations!(heatmap(fig[1, 3], c3[1, :, :, 1, 1].data.data, axis = (title = \"Explicit SM\",)).axis)\nfig","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"","category":"page"},{"location":"generated/tutorials/multiPatch/","page":"Multi-Patch","title":"Multi-Patch","text":"This page was generated using Literate.jl.","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/#math","page":"Parameters","title":"```math","text":"","category":"section"},{"location":"parameters/#\\begin{equation}","page":"Parameters","title":"\\begin{equation}","text":"","category":"section"},{"location":"parameters/#\\underset{\\mathbf{x}}{argmin}-\\frac{1}{2}\\vert\\vert-\\mathbf{S}\\mathbf{c}-\\mathbf{u}-\\vert\\vert_22-\\mathbf{R(x)}","page":"Parameters","title":"\\underset{\\mathbf{x}}{argmin} \\frac{1}{2}\\vert\\vert \\mathbf{S}\\mathbf{c}-\\mathbf{u} \\vert\\vert_2^2 + + \\mathbf{R(x)}","text":"","category":"section"},{"location":"parameters/#\\end{equation}","page":"Parameters","title":"\\end{equation}","text":"","category":"section"},{"location":"parameters/#","page":"Parameters","title":"```","text":"","category":"section"},{"location":"generated/howtos/extensions/#Implement-Reconstruction-Packages","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"","category":"section"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"In the Custom Data Processing and Algorithms how-to, we showed how to create custom parameters, processing steps and algorithms. We also showed that we can create empty RecoPlans with new custom structures. The only thing missing to fully make such blueprints available to the usual MPIReco interface is to essentially tell MPIReco about our custom structures and blueprints.","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"Let's implement a small Julia package for our weighting strategy:","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"module CustomWeighting\n  using MPIReco\n  using MPIReco.AbstractImageReconstruction\n\n  export AlternatingWeightingParameters\n  Base.@kwdef struct AlternatingWeightingParameters <: AbstractWeightingParameters\n    alternatingWeights::Vector{Float64}\n  end\n\n  function AbstractImageReconstruction.process(::Type{<:AbstractMPIRecoAlgorithm}, params::AlternatingWeightingParameters, freqs::Vector{CartesianIndex{2}}, args...)\n    alternatingWeights = Iterators.cycle(params.alternatingWeights) # Infinitely cycle through our weights\n    weights = collect(Iterators.take(alternatingWeights, length(freqs)))\n    return weights\n  end\nend","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"To use this module, a user could simply import both MPIReco and CustomWeighting:","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"using MPIReco, .CustomWeighting\nplan = MPIRecoPlan(\"SinglePatch\")\nsetAll!(plan, :weightingParams, AlternatingWeightingParameters(collect(range(0.0, 1.0, length=5))))","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"However, they won't be able to do something like","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"reconstruct(\"SinglePatchAlternating\", b; kwargs...)","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"just yet.","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"We first have to store a blueprint in some directory dir. This could be an directory within our CustomWeighting package or an expected folder in the users filesystem. Secondly, we need to tell MPIReco which modules it should consider when loading a blueprint. We can do both these things in the initialization function of our package:","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"module CustomWeighting\n  # ... same code as above\n\n  dir = joinpath(@__DIR__(), \"..\", \"Plans\")\n  function __init__()\n    addRecoPlanPath(dir)\n    addRecoPlanModule(CustomWeighting)\n  end\nend","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"Afterwards a user can simply invoke our reconstruction algorithms just like they would the provided reconstruction algorithms.","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"","category":"page"},{"location":"generated/howtos/extensions/","page":"Implement Reconstruction Packages","title":"Implement Reconstruction Packages","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/lowlevel/#Low-Level-Reconstruction","page":"Low-Level","title":"Low-Level Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"include(\"../../download.jl\") #hide\nusing MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")) #hide","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"In low-level reconstruction we manually supply both the system matrix mathbfS and the preprocessed measurement vector mathbfu. As an example we will reproduce a high-level reconstruction with the low-level interface:","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"params = Dict{Symbol, Any}()\nparams[:SNRThresh] = 5\nparams[:sf] = bSF\nparams[:frames] = 1:acqNumFrames(b)\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:rxNumChannels(b)\nparams[:iterations] = 1\nparams[:spectralLeakageCorrection] = true;\nparams[:reg] = [L2Regularization(0.0f0)]\n\n\ncHigh = reconstruct(\"SinglePatch\", b; params...);\nnothing #hide","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"While it is possible to manually invoke the processing steps involved in an algorithms reconstruction, we will instead call the respective procsesing functions of MPIFiles to prepare mathbfu:","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"freqs = filterFrequencies(bSF, SNRThresh = 5, minFreq = 80e3, recChannels = 1:rxNumChannels(b))\nu = getMeasurementsFD(b, frames = 1:acqNumFrames(b), frequencies = freqs, spectralLeakageCorrection=true)","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"And afterwards use MPIRecos utility functions to prepare mathbfS:","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"sparseTrafo = nothing\nS, grid = getSF(bSF, freqs, sparseTrafo, Kaczmarz)\ntypeof.([S, grid])","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"Now we can configur a low-level reconstruction:","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"cLow = reconstruct(\"LowLevel\", u; S = S, iterations = params[:iterations], reg = params[:reg])","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"Note that the low-level reconstruction returns a matrix without any metadata unlike the other reconstructions. The second dimension of the result matrix are the frames. To compare and plot our data we have to reshape it:","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"sliceLow = sliceLow = reshape(cLow[:, 1], Tuple(grid.shape))\nusing CairoMakie #hide\nfig = Figure();\nhidedecorations!(heatmap(fig[1, 1], cHigh[1, :, :, 1, 1].data.data, axis = (title = \"High\",)).axis)\nhidedecorations!(heatmap(fig[1, 2], sliceLow[:, :, 1], axis = (title = \"Low\",)).axis)\nfig","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"","category":"page"},{"location":"generated/tutorials/lowlevel/","page":"Low-Level","title":"Low-Level","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/multiContrast/#Multi-Contrast-Reconstruction","page":"Multi-Contrast","title":"Multi-Contrast Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"So far we have discussed single-contrast reconstructions of the form:","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"beginequation\n  undersetmathbfcargmin frac12vertvert mathbfSmathbfc-mathbfu vertvert_2^2 + + mathbfR(x)\nendequation","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"where mathbfS is a single system matrix, mathbfu is the measurement vector, and mathbfR(x) is an (optional) regularization term. In a multi-contrast reconstruction one can use two or more system matrices to solve:","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"beginequation\n   undersetc1c2argmin frac12left mathbfS_1S_2 beginpmatrix mathbfc_1  mathbfc_2 endpmatrix - mathbfu right_2^2 + mathbfR(x)\nendequation","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"To apply this technique to our algorithms, we simply have to provide multiple system matrices to our reconstructions:","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"using MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")) #hide\nbContrast = MultiContrastFile([bSF, bSF])","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"and can then reconstruct as usual:","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"c = reconstruct(\"SinglePatch\", b;\n                   SNRThresh=5,\n                   sf = bContrast,\n                   frames=1:acqNumFrames(b),\n                   minFreq=80e3,\n                   recChannels=1:rxNumChannels(b),\n                   iterations=1,\n                   spectralLeakageCorrection=true);\nsize(c)","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"Note that c now has two entries in its first dimension, one for each contrast.","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"We can then just simply access the data of each contrast by accessing the specific dimensions:","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"using CairoMakie #hide\nfig = Figure();\nhidedecorations!(heatmap(fig[1, 1], c[1, :, :, 1, 1].data.data, axis = (title = \"Contrast 1\",)).axis)\nhidedecorations!(heatmap(fig[1, 2], c[2, :, :, 1, 1].data.data, axis = (title = \"Contrast 2\",)).axis)\nfig","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"In this case the channels are identical, because we reused the same system matrix.","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"","category":"page"},{"location":"generated/tutorials/multiContrast/","page":"Multi-Contrast","title":"Multi-Contrast","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/explanations/recoplans/#MPIRecoPlans","page":"MPIRecoPlan","title":"MPIRecoPlans","text":"","category":"section"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"using MPIReco #hide","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"In this explanation we focus on the blueprint mechanism RecoPlans of AbstractImageReconstruction and how these are used in MPIReco. We start with a quick recap of the RecoPlan interface and then see how MPIReco uses it.","category":"page"},{"location":"generated/explanations/recoplans/#RecoPlans","page":"MPIRecoPlan","title":"RecoPlans","text":"","category":"section"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"RecoPlans are blueprints from which parameters and algorithms can be constructed. They are essentially thin-wrappers around nested-key value pairs. Plans are able to represent the nested tree structure of algorithms and their parameters. A plan can either be empty, partially or fully parameterized. Empty plans are helpful to describe just the structure of an algorithm, which a user can then parameterize. If a plan is constructed this way, it is missing all parameters:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"using MPIReco.AbstractImageReconstruction\nplan = RecoPlan(CommonPreProcessingParameters)\nplan.frames","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"We can interact with the plan as if it were a mutable variant of the given parameters:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"plan.frames = 1:10\nplan.bgParams = NoBackgroundCorrectionParameters()\nplan","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"And we can construct instances of parameters and algorithms from a plan:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"parameter = build(plan)","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"Likewise we can go from an instance to a plan via:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"plan = toPlan(parameter)","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"We can either manually empty a plan from its parameters:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"plan.frames = missing","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"Or use the clear! method, which preserves the structure of a blueprint by default:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"clear!(plan)","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"RecoPlans can be written to and read from files:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"plan.frames = 1:42\nplan.loadasreal = true\nplan.numAverages = rand(1:100)\ntoTOML(stdout, plan) #hide\ntoTOML(joinpath(@__DIR__, \"Parameters.toml\"), plan)","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"This way one can either serialize a completely parametrized image reconstruction or just the blueprint of an algorithm.","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"For more information on RecoPlans, we refer to the How-to section of the AbstractImageReconstruction documentation.","category":"page"},{"location":"generated/explanations/recoplans/#MPIRecoPlan","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"","category":"section"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"MPIReco facilitates access to RecoPlans via two additional features. The first features deals with loading RecoPlans. To load a RecoPlan from a file one has to provide the filename and a list of modules in which the respective algorithms and parameters are defined. MPIReco tracks a list of directories and modules to grant a user easier access to plans contained within the directories.","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"As was shown in the Implement Reconstruction Packages how-to, it is possible to register new modules and directory to MPIReco:","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"addRecoPlanPath(@__DIR__())\nplan = MPIRecoPlan(joinpath(@__DIR__, \"Parameters\"))","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"The second feature was shown in the Enable Caching how-to. This feature is realized by MPIReco keeping a least-recently-used (LRU) cache for recently opened plans. As long as the plan structure was not changed in the file or the parameters, a plan can be reused from the cache. While this also saves costs in loading a plan, the main benefit is reusing the same plan instance. If the plan in question contains processing steps that implement caching, all algorithms derived from a plan can access this cache. This enables an algorithm to reuse the results of previous processing steps.","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"","category":"page"},{"location":"generated/explanations/recoplans/","page":"MPIRecoPlan","title":"MPIRecoPlan","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"references/parameters/#Weighting","page":"Parameters","title":"Weighting","text":"","category":"section"},{"location":"references/parameters/#Background-Correction","page":"Parameters","title":"Background Correction","text":"","category":"section"},{"location":"references/parameters/#System-Matrix","page":"Parameters","title":"System Matrix","text":"","category":"section"},{"location":"references/parameters/#Least-Squares","page":"Parameters","title":"Least-Squares","text":"","category":"section"},{"location":"datasetStore/#Layers","page":"-","title":"Layers","text":"","category":"section"},{"location":"datasetStore/","page":"-","title":"-","text":"The reconstruction function has several layers starting from a high level over several middle layer to low layer functions. The most high level method has the following signature `julia reconstruction(dMDFDatasetStore studyStudy expExperiment recoParamsDictStringAny)","category":"page"},{"location":"generated/howtos/custom/#Custom-Data-Processing-and-Algorithms","page":"Implement Custom Data Processing","title":"Custom Data Processing and Algorithms","text":"","category":"section"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"include(\"../../download.jl\") #hide\nusing MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")); #hide\nnothing #hide","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"This how-to provides a quick guide on how to customize reconstruction algorithms. For more information on how to extend algorithms and processing steps, we refer to the Explanations section of the documentation and to the example section of AbstractImageReconstructions documentation.","category":"page"},{"location":"generated/howtos/custom/#Custom-Processing-Steps","page":"Implement Custom Data Processing","title":"Custom Processing Steps","text":"","category":"section"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"To implement a custom processing step, we need to add a new parameter struct, in our case we want to extend AbstractWeightingParameters. As a toy-example, we will implement a weighting strategy in which frequencies are weighting with an alternating sequence of weights:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"Base.@kwdef struct AlternatingWeightingParameters <: AbstractWeightingParameters\n  alternatingWeights::Vector{Float64}\nend","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"The Base.@kwdef macro generates a keyword-argment constructor with optional default values. Next, we can implement the actual processing function.","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"Different algorithms can have different implementations of a given weighting strategy and we can specialise a function on the type of algorithm or an algorithm instance itself. The former is helpful for pure functions, i.e. processing steps which solely depend on the given parameter and processing-arguments, not the state of the algorithm. The generic weight-process function takes as input the frequencies and the system matrix operator. In our case we only require the frequencies:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"function AbstractImageReconstruction.process(::Type{<:AbstractMPIRecoAlgorithm}, params::AlternatingWeightingParameters, freqs::Vector{CartesianIndex{2}}, args...)\n  alternatingWeights = Iterators.cycle(params.alternatingWeights) # Infinitely cycle through our weights\n  weights = collect(Iterators.take(alternatingWeights, length(freqs)))\n  return weights\nend","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"After implementing our processing function, we can directly use it within our exisintg algorithm blueprints:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"params = Dict{Symbol, Any}()\nparams[:SNRThresh] = 5\nparams[:frames] = 1:1\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:2\nparams[:spectralLeakageCorrection] = true\nparams[:sf] = bSF\nparams[:reg] = [L2Regularization(0.1f0)]\n\nourWeighting = AlternatingWeightingParameters(collect(range(0.0, 1.0, length=5)))","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"We can use either the high-level interface:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"c1 = reconstruct(\"SinglePatch\", b; params..., weightingParams = ourWeighting);\nnothing #hide","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"Or the RecoPlan interface:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"plan = MPIRecoPlan(\"SinglePatch\")\nsetAll!(plan, params)\nsetAll!(plan, :weightingParams, ourWeighting)\nalgo = build(plan)\nc2 = reconstruct(algo, b)\nisapprox(c1.data.data, c2.data.data)","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"We can visualize the results of our weighting:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"using CairoMakie\nfig = heatmap(c1[1, :, :, 1, 1].data.data)\nhidedecorations!(fig.axis)\nfig","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"The SinglePatch algorithm which we adapted with our new weighting strategy, actually allows weighting results to be cached.","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"plan = MPIRecoPlan(\"SinglePatch\")\ntypeof(plan.parameter.reco.weightingParams)","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"By overwritting the weightingParams, we removed the caching layer. If we want to use our adapted reconstruction algoritm with the best performace, we have to retain the caching layer:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"plan.parameter.reco.weightingParams.param = ourWeighting\nsetAll!(plan, params)\nalgo = build(plan)\nc3 = reconstruct(algo, b)\nisapprox(c1.data.data, c3.data.data)","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"We can then turn out algorithm into a plan and store it somewhere:","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"plan = toPlan(algo)\nAbstractImageReconstruction.clear!(plan)\ntoTOML(stdout, plan)","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"The How-to on Implement Reconstruction Packages shows to make such a plan available to the usual MPIReco interfaces.","category":"page"},{"location":"generated/howtos/custom/#Custom-Reconstruction-Algorithms","page":"Implement Custom Data Processing","title":"Custom Reconstruction Algorithms","text":"","category":"section"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"So far, we created new \"variant\" of an image reconstruction algorithm by adding a new strategy of an existing processing step. However, if our new reconstruction algorithm requires overall different data processing, such as for example an X-space reconstruction, we need to implement a new AbstractMPIRecoAlgorithm.","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"The AbstractImageReconstruction.jl documentation has examples of full algorithm implementations. We recommend reading those and then reading the implementation of the single-patch reconstruction algorithm as a starting point.","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"","category":"page"},{"location":"generated/howtos/custom/","page":"Implement Custom Data Processing","title":"Implement Custom Data Processing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/distributed/#Distributed-Image-Reconstruction","page":"Distributed Reconstruction","title":"Distributed Image Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"MPIReco image reconstructions can also be executed across different computers, thanks to DaggerImageReconstruction. With this feature one could perform a reconstruction over the network on a machine with some specific resource, be it a specific system matrix or access to a GPU.","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"To enable a distributed reconstruction one has to first use the Distributed standard library to add a new Julia process on the remote machine.","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"using Distributed\nworkers = addprocs([\"remote_address])\nworker = first(workers)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"using Distributed #hide\nworker = 1 #hide # comment out to properly connect to a different process","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"The worker is the Julia process id, which is used to identify where to move data to and perform computations on. Afterwards we just load both MPIReco and DaggerImageReconstruction:","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"using MPIReco, DaggerImageReconstruction","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"Instead of a MPIFile, we now want to create a DMPIFile, a distributed MPIFIle. Such a file expects a path on the remote machine together with the worker id:","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"distr_bSF = DMPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\"), worker = worker)\ndistr_b = DMPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\"), worker = worker)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"Note that you might need to consider differences between the operating systems of both machines. For example, in this case we constructing our filepath locally, while evaluating it on the remote. You could also construct the path on the worker with:","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"remotecall_fetch(() -> joinpath(\"...\"), worker)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"Once we have our distributed files, we can configure our reconstruction like usual and the algorithm figures out on which worker to execute based on the provided distributed MPIFiles. In this case, both files were located on the remote. If the measurements are located on the local machine, then one has to transfer the data over the network.","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"c1 = reconstruct(\"SinglePatch\", distr_b;\n                   SNRThresh=5,\n                   sf = distr_bSF,\n                   frames=1:acqNumFrames(distr_b),\n                   minFreq=80e3,\n                   recChannels=1:rxNumChannels(distr_b),\n                   iterations=1,\n                   spectralLeakageCorrection=true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"Most MPIFiles instances are just handles to one or more local files and thus can't be meaningfully send over the network. To get around this, you can transform an MDF into an MDFinMemory, which is a fully in-memory representation of an MDF.","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"b = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\"))\nbInMemory = MDFv2InMemory(b)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"Now the algorithm can't determinte the worker from the measurement anymore and we have to utilize the loadDaggerPlan function from DaggerImageReconstruction. This function expects a path to a local RecoPlan, which is then constructed on the given worker:","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"planpaths = getRecoPlanList(;full=true)\nindex = findfirst(endswith(\"SinglePatch.toml\"), planpaths)\ndistr_plan = loadDaggerPlan(planpaths[index], getRecoPlanModules(), worker = 1)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"We can then configure the plan as usual:","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"setAll!(distr_plan; SNRThresh=5,\n                   sf = distr_bSF,\n                   frames=1:acqNumFrames(bInMemory),\n                   minFreq=80e3,\n                   recChannels=1:rxNumChannels(bInMemory),\n                   iterations=1,\n                   spectralLeakageCorrection=true)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"And perform a normal reconstruction with it:","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"distr_algo = build(distr_plan)\nc2 = reconstruct(distr_algo, bInMemory)\nisapprox(c1.data.data, c2.data.data)","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"","category":"page"},{"location":"generated/tutorials/distributed/","page":"Distributed Reconstruction","title":"Distributed Reconstruction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"references/multipatch/#Multi-Patch-Algorithms","page":"Multi-Patch","title":"Multi-Patch Algorithms","text":"","category":"section"},{"location":"references/singlepatch/#Single-Patch-Algorithms","page":"Single-Patch","title":"Single-Patch Algorithms","text":"","category":"section"},{"location":"references/utility/#Utility-Functions","page":"Utility","title":"Utility Functions","text":"","category":"section"},{"location":"generated/howtos/callbacks/#Callbacks","page":"Use Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"include(\"../../download.jl\") #hide\nusing MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")); #hide\nnothing #hide","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"RegularizedLeastSquares provides a callback mechanism that allows you to access and monitor the state of the optimization process. These callbacks are invoked at the start of each iteration and have the form f(solver, iteration). Via the solver, you can access any internal property of the solver state.","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"MPIReco exposes this interface for compatible algorithms. You can use do-syntax to pass a callback of the form f(solver, frame, iteration) to the reconstruction:","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"parameters = Dict{Symbol, Any}() #hide\nparameters[:SNRThresh] = 5 #hide\nparameters[:sf] = bSF #hide\nparameters[:frames] = 1:acqNumFrames(b) #hide\nparameters[:minFreq] = 80e3 #hide\nparameters[:recChannels] = 1:rxNumChannels(b) #hide\nparameters[:iterations] = 3 #hide\nparameters[:spectralLeakageCorrection] = true; #hide\nc = reconstruct(\"SinglePatch\", b; parameters...) do solver, frame, iteration\n  tmp = sum(solversolution(solver))\n  @info \"Sum of concentration at frame $frame and iteration $iteration is $tmp\"\nend","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"MPIReco also provides built-in callbacks that can store the solution in each iteration or compare the current solution with a reference:","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"cb = StoreSolutionPerFrameCallback()\nreconstruct(cb, \"SinglePatch\", b; parameters...);\ncb.solutions[1]","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"You can also combine multiple callbacks:","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"cb1 = StoreSolutionPerFrameCallback()\nref = reshape(c[1, :, :, :, 1].data.data, :, 1)\ncb2 = CompareSolutionPerFrameCallback(ref)\nreconstruct(\"SinglePatch\", b; parameters...) do solver, frame, iteration\n  cb1(solver, frame, iteration)\n  cb2(solver, frame, iteration)\nend\ncb2.results[1]","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"Note that callbacks are used directly in the solver and thus reflect its value domain. This means that in sparse reconstruction, the current solution approximation is not in the image domain. Likewise, the solution might still be a complex number.","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"Both variants shown above get passed as a callbacks keyword argument to the algorithm. When using the callback directly like this, the interface changes from f(solver, frame, iteration) to f(solver, iteration). And you have to manually differentiate between frames by watching for the start of a new reconstruction:","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"frame = 0\nfunction my_callback(solver, iteration)\n  if iteration == 0\n    global frame += 1\n  end\n  @info \"Frame $frame, Iteration $iteration\"\nend\nreconstruct(\"SinglePatch\", b; parameters..., callbacks = my_callback);\nnothing #hide","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"","category":"page"},{"location":"generated/howtos/callbacks/","page":"Use Callbacks","title":"Use Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/overview/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"To begin, we first need to gather some MPI data. To do this we could use data from the OpenMPIData initiative, however for these examples we will use the data used in testing MPIReco.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"To access this test data, first, enter the Pkg mode in Julia (]) and execute the unit tests of MPIReco::","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"test MPIReco","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"This will download and unpack some MPI measurements and calibration MDF files and perform tests with the data. The download location will be printed at the start of the test execution. You can cancel the test execution once the data is downloaded by pressing Ctrl + C or closing the Julia process.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"After the download, several MPI files will be present in the specified directory. All subsequent examples assume that you have assigned the path to this directory to a variable named datadir:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"include(\"../../download.jl\"); #hide\nnothing #hide","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"const datadir = joinpath(\"...\",\"artifacts\", \"...\") # enter path here","category":"page"},{"location":"generated/tutorials/overview/#First-Reconstruction","page":"Getting Started","title":"First Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"We will start looking at a small reconstruction script. First, we load MPIReco:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"using MPIReco","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Next, we open handles for the system matrix and measurement data. Both are created via MPIFile function, which can be, for instance, an MDFFile or a BrukerFile.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"bSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\"))\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\"))","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"To interact with the files, you can use the functionality of MPIFiles, which is also exported by MPIReco:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"acqNumFrames(b)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"We refer to the documentation for MPIFiles.jl and MDF for more information on the available data and functions.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Now we will perform a system-matrix based reconstruction using the reconstruct function. The function takes as arguments the algorithm to use, the measurement data, and various keyword arguments. The available parameters and their interpretation depend on the chosen algorithm. In this case, the algorithm also expects the system matrix to be set. We set the SNR threshold to 5, meaning that only matrix rows with an SNR above 5 will be used during reconstruction. The parameter frame decides which frame of the measured data should be reconstructed.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"c = reconstruct(\"SinglePatch\", b;\n                   SNRThresh=5,\n                   sf = bSF,\n                   frames=1:acqNumFrames(b),\n                   minFreq=80e3,\n                   recChannels=1:rxNumChannels(b),\n                   iterations=1,\n                   spectralLeakageCorrection=true)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Notice that the result is not just an array of particle concentration, but contains a variety of metadata as well. This is because c is a:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"typeof(c)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"You can access metadata as properties, such as:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"c.tracerName","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"The result can also be treated like a normal 5-dimensional array. The first dimension is for different contrasts, followed by the three spatial dimensions and lastly the temporal dimension of the different frames.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"size(c)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"You can access the underlying data just like any other array in Julia. For example, you can access an XY slice as follows:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"slice = c[1, :, :, 1, 1]\ntypeof(slice)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"Note that the slice is still an ImageMeta array. Inside the array is an AxisArray, another array type with metadata. Not every Julia package has methods for such metadata arrays. To visualize our results with CairoMakie, we need to extract the underlying data.","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"sliceRaw = slice.data.data\ntypeof(sliceRaw)","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"We can now visualize our first MPI reconstruction using MPIReco:","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"using CairoMakie\nfig = heatmap(sliceRaw)\nhidedecorations!(fig.axis)\nfig","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"generated/tutorials/overview/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/howtos/caching/#Enable-Caching","page":"Enable Caching","title":"Enable Caching","text":"","category":"section"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"Image reconstructions implemented with AbstractImageReconstruction.jl are composed of several individual processing steps which form the whole (computationally expensive) image recosntruction procses. Often time one wants to slightly modify reconstruction parameters, for example when searching for good regularization parameters. AbstractImageReconstruction.jl offers a caching option in which algorithms can reuse intermediate processing results, as long as those are unaffected by the parameter changes.","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"This caching mechanism has to be explicitly added in the implementation of an algorithm and an algorithms RecoPlan. All algorithms constructed from the same plan, can access the same cache. To make this behaviour available to the high-level reconstruct interface, MPIReco can cache RecoPlans between reconstructions:","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"using MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\"))\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\"))\nparams = Dict{Symbol, Any}()\nparams[:SNRThresh] = 5\nparams[:frames] = 1:1\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:2\nparams[:spectralLeakageCorrection] = true\nparams[:sf] = bSF\nparams[:reg] = [L2Regularization(0.1f0)];\nnothing #hide","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"Caching is disabled by default and if you modify the blueprint of a plan, for example by providing a different weighting strategy. To opt into caching you call a reconstruction with a true flag as the third argument:","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"initial = @elapsed reconstruct(\"SinglePatch\", b, true; params...)\nsecond = @elapsed reconstruct(\"SinglePatch\", b, true; params...)\ninitial/second # speedup","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"Changing a parameter which affects the cache result, in this case the loading of the system matrix, invalidates the cache:","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"third = @elapsed reconstruct(\"SinglePatch\", b, true; params..., SNRThresh = 2)\ninitial/third","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"It is possible to manually empty the MPIRecos cache of blueprints and thus release any large cached results:","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"emptyRecoCache!();\nnothing #hide","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"The number of cached reconstruction plans can be set via the MPIRECO_CACHE_SIZE environment variable. Note that restarting is necessary for it to take any effect.","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"When directly constructing a plan, all algorithms build from it can benefit from the plans caching:","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"plan = MPIRecoPlan(\"SinglePatch\")\nsetAll!(plan, params)\nresults = []\nfor  in [0.1f0, 0.5f0, 1.0f0]\n  setAll!(plan, :reg, [L2Regularization()])\n  c = reconstruct(build(plan), b)\n  push!(results, c[1, :, :, 1, 1].data)\nend\nusing CairoMakie #hide\nfig = Figure();\nhidedecorations!(heatmap(fig[1, 1], results[1], axis = (title = \" = 0.1\",)).axis)\nhidedecorations!(heatmap(fig[1, 2], results[2], axis = (title = \" = 0.5\",)).axis)\nhidedecorations!(heatmap(fig[1, 3], results[3], axis = (title = \" = 1.0\",)).axis)\nfig","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"This type of caching bypasses MPIRecos cache and results are only freed if there is no reference to the plan available anymore:","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"plan = nothing","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"","category":"page"},{"location":"generated/howtos/caching/","page":"Enable Caching","title":"Enable Caching","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/matrixCompression/#Matrix-Compression-Techniques","page":"Compression","title":"Matrix-Compression Techniques","text":"","category":"section"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"Matrix compression can significantly accelerate the reconstruction process. This is achieved by transforming the system matrix S into a different domain through a basis transformation applied to its rows.","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"In MPIReco.jl, matrix compression can be enabled by specifying a sparse system-matrix loading parameter and selecting the desired sparsity transformation.","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"using MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"7.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\",\"20211226_204612_Dice\", \"1.mdf\")) #hide\nparams = Dict{Symbol, Any}()\nparams[:SNRThresh] = 2\nparams[:frames] = 1:100\nparams[:numAverages] = 100\nparams[:minFreq] = 80e3\nparams[:recChannels] = 1:2\nparams[:iterations] = 3\nparams[:spectralLeakageCorrection] = false\nparams[:sf] = bSF;\nnothing #hide","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"We first reconstruct as usual:","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"cDense = reconstruct(\"SinglePatch\", b; params...);\nnothing #hide","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"Afterwards we use a blueprint with a sparse system-matrix loading and setting a sparsity transformation:","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"cSparse = reconstruct(\"SinglePatchSparse\", b; params..., sparseTrafo = \"FFT\");\nnothing #hide","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"Possible transformations are \"FFT\", \"DCT_IV\" and \"DST\".","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"The transformations can be restricted to the drive-field field-of-view by setting useDFFoV = true. The compression factor, which controls how many coefficients are dropped after applying the transformation, is determined by the redFactor parameter. For example, a reduction factor of redFactor = 0.01 will drop 99% of the data.","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"cRed = reconstruct(\"SinglePatchSparse\", b; params..., sparseTrafo = \"FFT\", useDFFoV = true, redFactor = 0.01);\nnothing #hide","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"We can again visualize the data with CairoMakie:","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"using CairoMakie #hide\nfig = Figure();\nhidedecorations!(heatmap(fig[1, 1], cDense[1, :, :, 1, 1].data.data, axis = (title = \"Dense\",)).axis)\nhidedecorations!(heatmap(fig[1, 2], cSparse[1, :, :, 1, 1].data.data, axis = (title = \"Sparse\",)).axis)\nhidedecorations!(heatmap(fig[1, 3], cRed[1, :, :, 1, 1].data.data, axis = (title = \"Sparse DF FOV\",)).axis)\nfig","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"","category":"page"},{"location":"generated/tutorials/matrixCompression/","page":"Compression","title":"Compression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/basicReconstruction/#Basic-Reconstruction","page":"Basic Reconstructions","title":"Basic Reconstruction","text":"","category":"section"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"include(\"../../download.jl\") #hide","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"MPIReco.jl provides different reconstruction interfaces. All of the interfaces interact with RecoPlans from AbstractImageReconstruction. These are blueprints from which different algorithms can be constructed. from which different algorithms can be constructed. For more details on these blueprints, we refer to the AbstractImageReconstruction documentation.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"The reconstruction algorithm in MPIReco mainly focus on system-matrix based reconstructions, where one considers an inverse problem of the form:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"beginequation\n  undersetmathbfcargmin frac12vertvert mathbfSmathbfc-mathbfu vertvert_2^2 + + mathbfR(x)\nendequation","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"where mathbfS is a system matrix, mathbfu is the measurement vector, and mathbfR(x) is an (optional) regularization term.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"MPIReco comes with a few prepared blueprints, however one can easily add and store their own blueprints. These can be new configurations of existing algorithms and parameters or even new ones developed in other packages. Such packages could provide algorithms which are not based on system-matrix reconstructions. To read more on how to write and integrate such packages, consult the How-Tos.","category":"page"},{"location":"generated/tutorials/basicReconstruction/#High-Level-Interface","page":"Basic Reconstructions","title":"High-Level Interface","text":"","category":"section"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"In the Getting Started section, we created our first MPI reconstruction as follows:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"using MPIReco #hide\nbSF = MPIFile(joinpath(datadir, \"calibrations\", \"12.mdf\")) #hide\nb = MPIFile(joinpath(datadir, \"measurements\", \"20211226_203916_MultiPatch\", \"1.mdf\")) #hide\n\nc = reconstruct(\"SinglePatch\", b;\n                   SNRThresh=5,\n                   sf = bSF,\n                   frames=1:acqNumFrames(b),\n                   minFreq=80e3,\n                   recChannels=1:rxNumChannels(b),\n                   iterations=1,\n                   spectralLeakageCorrection=true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"\"SinglePatch\" here refers to a blueprint for system-matrix based single-patch image reconstruction. The keyword arguments are used to set parameters defined in the blueprint.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"It is also possible to provide these parameters as a dictionary. This is especially helpful if you want to reuse parameters or change parameters programmatically.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"parameters = Dict{Symbol, Any}()\nparameters[:SNRThresh] = 5\nparameters[:sf] = bSF\nparameters[:frames] = 1:acqNumFrames(b)\nparameters[:minFreq] = 80e3\nparameters[:recChannels] = 1:rxNumChannels(b)\nparameters[:iterations] = 1\nparameters[:spectralLeakageCorrection] = true;\nnothing #hide","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"You can just pass the dictionary as an argument to the reconstruct function as follows:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"c2 = reconstruct(\"SinglePatch\", b; parameters...)\nisapprox(c.data, c2.data)","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"It is also possible to combine both methods of defining parameters:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"c3 = reconstruct(\"SinglePatch\", b; parameters..., recChannels = 1:1)\nc3.rxNumChannels","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"Here, we overwrote the recChannels parameter within in the dictionary.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"We can retrieve a list of all available blueprints that MPIReco can find using:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"getRecoPlanList()","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"This list returns the filenames of the blueprints. In the reconstruct call, you only need to refer to the name without an extension.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"To get the full paths of each blueprint, use:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"planpaths = getRecoPlanList(;full=true)","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"You can add custom directories for MPIReco to search for blueprints. Other packages might do this automatically when they are loaded.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"It is also possible to specify a direct path to a blueprint in the reconstruct function.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"index = findfirst(endswith(\"SinglePatch.toml\"), planpaths)\nc4 = reconstruct(planpaths[index], b; parameters...)\nisapprox(c.data, c4.data)","category":"page"},{"location":"generated/tutorials/basicReconstruction/#RecoPlan-Interface","page":"Basic Reconstructions","title":"RecoPlan Interface","text":"","category":"section"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"You can also directly access a blueprint via:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"plan = MPIRecoPlan(\"SinglePatch\")","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"This allows you to see all parameters associated with the blueprint and configure them individually. The keyword arguments previously mentioned apply to all parameters with the same name. Note that different parameters in different contexts can share the same name in RecoPlans.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"To modify specific parameters of the plan, you can directly access its properties:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"plan.parameter.reco.sf = bSF","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"Although we only updated the system matrix parameter, the plan now also includes derived values from the system matrix, such as the grid size.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"plan.parameter.reco","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"This worked because the SinglePatch blueprint has connections between parameters. These connections depend on the blueprint itself and are not hardcoded in MPIReco.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"You can also utilize the previously created dictionary to configure the plan:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"setAll!(plan, parameters)","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"Alternatively, you can set all parameters of a specific name directly:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"setAll!(plan, :iterations, 3)","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"Once the plan is configured, you can construct an algorithm from it using:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"algo = build(plan);\nnothing #hide","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"After constructing the algorithm, you can perform multiple reconstructions and reuse the algorithm with:","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"c = reconstruct(algo, b);\nnothing #hide","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"Depending on the algorithm, it might be faster to reconstruct multiple measurements from a RecoPlan, instead of the high-level interface. For more information on that, we refer to the How-To for caching. Algorithms are usually thread-safe, though they might not necessarily run concurrently.","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"","category":"page"},{"location":"generated/tutorials/basicReconstruction/","page":"Basic Reconstructions","title":"Basic Reconstructions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"datastructures/#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"MPIReco contains several different groups of data structures which will be explained in more details in this and the following explanation pages. This page focuses on the core data structures used during image reconstruction, while MPIRecoPlan focuses on the blueprint mechanisms of AbstractImageReconstruction and its interaction with MPIReco. And lastly, Imaging Operators highlights the requirements and structure of the operators used during image reconstruction.","category":"page"},{"location":"datastructures/#AbstractImageReconstruction","page":"Data Structures","title":"AbstractImageReconstruction","text":"","category":"section"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"Image reconstruction using AbstractImageReconstruction.jl allows for flexible control of the reconstruction process and data flow based on individual processing steps. The flow of these steps is defined by Julia's multiple dispatch mechanism applied to algorithms, their (configuration) parameters, and the input arguments of the processing steps.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"abstract type AbstractImageReconstructionParameters end","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"Parameters are adjustable settings used during image reconstruction. Users can typically configure these through keyword arguments. Parameters can be nested and may contain other parameters.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"abstract type AbstractImageReconstructionAlgorithm end","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"Algorithms are the data structures responsible for executing image reconstruction and provide the context within which a given set of parameters is evaluated. Different algorithms may have slightly different implementations of a processing step for the same parameter. Algorithms are usually stateful and implement a thread-safe FIFO behavior.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"function process(algo, params, inputs...)\n  # ...\nend","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"Processing steps are the internal steps used during image reconstruction. Each algorithm defines the control flow for its processing steps by invoking process on itself, a parameter, and some input values, such as a file or an array of measurement data.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"A process can in turn invoke another process function with, for example, a different nested parameter or a changed input value. Processing can occur with either an instance of an algorithm or the type of an algorithm. The latter case represents pure processing steps, which can be easily cached and reused between subsequent image reconstructions.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"The AbstractImageReconstruction.jl documentation features a complete example of how to assemble all these components into a working image reconstruction algorithm, which provides the high-level interface reconstruct(algo, data). Alternatively, one can read the implementation of the provided MPI reconstruction algorithms.","category":"page"},{"location":"datastructures/#MPIReco","page":"Data Structures","title":"MPIReco","text":"","category":"section"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"MPIReco extends the abstract types of AbstractImageReconstruction with its own type hierarchies for AbstractMPIRecoAlgorithms <: AbstractReconstructionAlgorithm and AbstractMPIRecoParameters <: AbstractReconstructionParameters. For example, the reconstruct(\"SinglePatch\", file) function constructs a SinglePatchAlgorithm, which extends AbstractSinglePatchAlgorithm, which in turn extends AbstractMPIRecoAlgorithm.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"The provided parameters are roughly grouped into preprocessing parameters, which focus on loading the correct data from MDFs, and reconstruction parameters, which focus on modifying and using the output of preprocessing to construct and solve the inverse problem of image reconstruction. Finally, post-processing parameters can be applied to the resulting images. While this rough grouping is used in the provided algorithms, custom algorithms can deviate to define and combine parameters as best fits their needs.","category":"page"},{"location":"datastructures/","page":"Data Structures","title":"Data Structures","text":"Many parameters provide a default implementation process(algoT::AbstractMPIRecoAlgorithm, param, inputs...), allowing any algorithm to invoke a standard utility, such as loading measurement data with a given filtering parameter.","category":"page"},{"location":"#MPIReco.jl","page":"Home","title":"MPIReco.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia package for the reconstruction of magnetic particle imaging (MPI) data","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project provides algorithms and utility functions for the reconstruction of MPI data. The project is implemented in the programming language Julia and its algorithms use the interface provided by the AbstractImageReconstruction.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MPIReco contains algorithms for a variety of system matrix based reconstructions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Single-Patch Reconstruction\nMulti-Patch Reconstruction for data that has been acquired using a focus field sequence\nMulti-Contrast Reconstruction for reconstructions using multiple system matrices\nMatrix-Compression Techniques","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, the existing algorithms can easily be adapted with new data processing steps and newly created algorithms can be seamlessly integrated into MPIRecos reconstruction interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key features are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Frequency filtering for memory efficient reconstruction. Only frequencies used during reconstructions are loaded into memory.\nDifferent solvers provided by the package RegularizedLeastSquares.jl\nHigh-level and low-level reconstruction interfaces provide maximum flexibility for the user\nFlexible algorithm definition and parametrization with AbstractImageReconstruction.jl and the possibilty to define and include custom reconstruction algorithms\nSpectral leakage correction (implemented in MPIFiles.jl)\nVendor agnostic GPU acceleration","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"add MPIReco","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the packages MPIReco.jl and all its dependencies. In particular this will install the core dependencies MPIFiles, RegularizedLeastSquares and AbstractImageReconstruction.jl.","category":"page"},{"location":"#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have problems using the software, find mistakes, or have general questions please use the issue tracker to contact us.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tobias Knopp\nMartin Mddel\nNiklas Hackelberg\nPatryk Szwargulski","category":"page"}]
}
